---
layout: post
title:  "《图解设计模式》阅读总结"
categories: 阅读笔记 设计模式
tags:  设计模式 阅读总结
author: toBeTheLight
---

* content
{:toc}
阅读《图解设计模式》的设计模式所思所想。
感觉这本书缺了不少东西，但是还是有收获的。







## 困惑

作者试图从另一个角度阐述设计模式，所以对 23 种具体设计模式进行了重新分类，但整本书读下来比较困惑，在于几点：

1. 分类标准不统一，有实现思路、实现内容、模式目的等标准，甚至还有“适应设计模式”这种分类，颇有些无从分类的“自暴自弃”的味道。同时在这种分类方式下，还存在一个问题，即某设计模式的实现是会用到另一个设计模式的，甚至其些设计模式的书中实现类图会基本相同，但是却属于不同分类，带来了新的困惑，好像要强迫你在学习一个设计模式时，要忘掉其他设计模式的存在。
2. 缺乏对具体设计模式适用场景的充分阐述，知何却不知为何。
3. 作为入门书，未对更低层的原则进行科普，即使知道了各具体模式可以达成哪些具体目的，却无法融汇到统一的思想出口。
4. ?

但是总觉得还有一个抓不到的原因，那么再深入探究一下，到底是什么令我产生困惑呢？这就需要了解设计模式的起源。

## 根源

设计模式（design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案

设计模式是问题的方案。

设计模式是经验的总结。

首先，正确的学习方式应该是带着问题找答案。如果答案被直接摆在面前却不知问题，不论是谁都会产生“这是弄啥！！”的困惑。但更重要的是，经验应该是具有普适性的，每种具体的设计模式其实体现的是一种具体的思想方式，这种思想方式与语言无关，在单一语言中也一定有多种实现形式，那么此时就进入到了抽象和具象的冲突。若无顿悟的天分，接收到这种思想的抽象（概念）描述，会有一种脑子懂了，却无从下手的感觉，若以有限的应用示例来描述，又无法完全体现思想的方方面面。

所以设计模式的学习应该是快速的阅读书籍，对模式有个轮廓的认识后，带着问题，不断实践练习的一个过程，在实践中对思想进行感悟，得出自己的体会。从书中得到的还要变成自己的融到自己的骨子里，这也是困惑的根本原因了，实践不够呀。

这其中还有另一个教训，我曾经陷入了为什么能用这种设计模式而不能用另一种设计模式的思维旋涡，这些问题不依靠大量实践是解决不了的。


所以后续内容也只会对设计模式的脉络做抽象的总结，不进行详细的阐述。

## 目的与手段

维护一个软件的长期良性发展是目的，即提高可维护性，降低维护成本，我们可以通过设计模式的思想去完成。可以把这种思想分为 3 层，从上到下越来越具体。

1. 标准：维护性、扩展性、重用性、高内聚、低耦合
2. 原则：7 条原则
3. 模式：23 + N 种设计模式

通过提升扩展性、重用性等达到高内聚、低耦合的特性。

这个过程中应遵循 7 大原则，同时这些原则又是设计模式的基础，是设计模式为何如此设计的依据。

模式则是更具体的表现，设计模式不仅仅局限于 23 种，跟随技术水平的发展，也伴生出了新的问题，也就总结出了针对新问题的模式。

## 7 大基本原则

由于 JS 并非基于类的语言，我们可以将下述原则的应用个体，如类、接口，放到函数或模块上体会。

* 单一职责原则：
  * 单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。
  * 我们不必要拘泥于类，该原则的根本目的是控制职责所在的个体复杂度。只需要明白单一个体只需要做好一件事，个体越简单则可读性越好，职责划分越明确，则改动发生时，越不会影响其他个体。
  * 比如这种职责拆分可以发生在函数粒度，也可以发生在函数的聚合层面（类或者更外层的函数），职责和个体理想状态下应该是一对一的。
  * 这个原则要求我们能清晰的认识到代码逻辑中的多重职责，从而才能进行划分。
* 接口隔离原则：
  * 客户端不应该被迫依赖于它不使用的方法。一个类对另一个类的依赖应该建立在最小的接口上。
  * 即对于依赖者，被依赖者应该只提供他关心的功能。当体现在接口上时，就是接口隔离原则，将有冗余的接口拆分。
  * 可以避免由于依赖者的增多导致接口膨胀，影响到其他的依赖者。
  * 相对于单一职责原则可以理解为单一职责原则是对内做最少承诺，而接口隔离原则是对外做最少的承诺。
* 依赖倒置原则：
  * 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
  * 即面向接口编程。我们只需要对低层进行接口定义，高层只需要关注有哪些接口并进行调用，低层实现时只要实现了这些接口，那么传给高层的实例发生变化时，高层就不需要修改。降低了耦合度。
* 开闭原则：
  * 软件实体应当对扩展开放，对修改关闭。
  * 在软件修改时，尽量通过扩展而实现而不是通过修改来实现，避免对现有逻辑的影响。
* 合成复用原则：
  * 在复用时，要尽量先使用**组合**（实例化是就存在）或者**聚合**（通过 API 调用添加为成员变量）等关联关系来实现，其次才考虑使用继承关系来实现。
  * 继承强耦合。
* 里氏替换原则：
  * 继承必须确保超类所拥有的性质在子类中仍然成立。即子类可以扩展父类的功能，但不能改变父类原有的功能。
* 迪米特法则：
  * 只与你的直接朋友交谈，不跟“陌生人”说话，又叫最少知识原则。即一个类对自己依赖的类知道的越少越好。
  * 耦合是无法完全避免的。
  * 被依赖的类不论多复杂，都应该将细节封装在内部，对外暴露 API。
  * 应该避免类中出现非直接的朋友关系（直接朋友关系：成员变量、参数、返回值）的依赖。

可以看出这些原则都是为了个体间的松耦合而努力。

## 一句话描述

1. **迭代器模式**：为了在不暴露数据的内部结构的前提下对外提供可替换的迭代方式。此模式隐藏内部细节，且可替换。可推广至非迭代能力。
2. **适配器模式**：为了使不兼容的接口协同工作，包装接口将现有接口包装为需要的接口。在处理代码边界、第三方依赖时也可使用。
3. **模板方法模式**：在流程结构确定，而步骤的具体实现不定或有差异时使用。将具体的处理实现交给子类，核心是定义好模板方法。
4. 工厂方法模式：创建接口不变的情况下，由用户决定什么哪个实例时，使用。产品和工厂一一对应，当增加新的产品时需要增加新的产品类和对应的工厂类。
5. **单例模式**：只允许生成一个实例的模式，核心在于限制为单一实例。
6. 原型模式：避免较高的实例化成本时使用，通过复制生成实例，核心在于复制现有实例，避免重走创建过程。
7. 建造者模式：组成部分相同，但组装过程可替换时使用。通过组装生成复杂实例，并将组装构造过程抽离至独立的指挥者类，核心在于侧重组装。
8. 抽象工厂模式：与工厂方法模式类似，但当工厂类产出多个产品时可以使用工厂方法模式。提供一个创建一组相关或相互依赖对象的接口，核心在于同一个工厂可生成不同的相关对象。
9. 桥接模式：往往在对外提供的功能接口内有多个维度的变化时使用，将类的功能和实现分离，功能接口通过组合关系使用实现类来完成具体实现，可防止类数量爆炸。
10. 策略模式：当我们完成任务的方法需要可替换时使用。将过程拆分为实现和使用，实现提供成系统的方法簇，供使用调用从而实现可替换，即策略可替换。
11. 组合模式：当对象间是部分-整体的层次结构，且不希望用户关注对象间差异，对外提供一致性的访问接口时使用。多个子类实现同一接口，共同暴露给用户。
12. **装饰器模式**：在不改变提供给用户的接口的前提下，给一个对象追加更多功能。
13. 访问者模式：在不改变数据结构的前提下可以添加作用于数据结构中元素的新的操作。将数据结构与对其中元素的操作分离。
14. **责任链模式**：个体需要被多个对象处理，但处理对象间有没有耦合关系时，为了避免系统复杂度时使用。将多个处理对象组成一条责任链，然后将待处理目标沿着这条链传递进行处理。Koa 中间件机制就是一种实践。
15. 门面模式：简化外部对复杂系统中子系统的联系，对外提供简单易用的接口时使用。也是屏蔽细节，但屏蔽的不是数据结构的细节。
16. 中介者模式：简化复杂系统中子系统之间的联系，将交互封装一个中介对象，降低系列对象间的耦合。体会下与门面模式的不同。
17. 观察者模式：一个对象的改变需要导致其他对象的改变，且不关心其他对象具体是谁时可以使用。观察对象管理监听他的所有观察者，并在发生变化时通知所有观察者。
18. 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。
19. 状态模式：将不同状态下的行为封装为不同的类，允许在状态改变时通过切换状态类改变行为。可以理解为策略模式的一种特殊应用。是一种内置了多种“策略”，根据状态变化切换“策略”的模式。
20. 享元模式：有大量的实例需要公用或重复使用时使用。我们可以把这些实例当做享元，并管理起来。可以当做多个维度的单例模式，生成的单例们，可能受外部因素影响，在返回前可能被修改状态。
21. 代理模式：在我们不想让用户直接使用到对象的情况下使用，此时可以使用代理模式控制用户访问。
22. 命令模式：需要使命令发起者和执行者不可见，甚至需要对命令加以管理时使用。此模式通过将命令封装为一个类，将命令执行者作为命令的依赖，分离命令调用者和命令实现者，同时由于命令实例的存在又可以对命令加以管理。
23. 解释器模式：将发生频率足够高的问题的各个实例表述为一个简单语言的句子，并构建一个解释器解释语言中的句子。

## 结语

学什么？

> 我们学设计模式，是为了学习如何合理的组织我们的代码，如何解耦，如何真正的达到对修改封闭对扩展开放的效果，而不是去背诵那些类的继承模式，然后自己记不住，回过头来就骂设计模式把你的代码搞复杂了，要反设计模式。

如何用？

> 为了合理的利用设计模式，我们应该明白一个概念，叫做扩展点。扩展点不是天生就有的，而是设计出来的。我们设计一个软件的架构的时候，我们也要同时设计一下哪些地方以后可以改，哪些地方以后不能改。倘若你的设计不能满足现实世界的需要，那你就要重构，把有用的扩展点加进去，把没用的扩展点去除掉。

如何用的好？

> “我亦无他，惟手熟尔。”

## 参考

* 《图解设计模式》
* [Java设计模式：23种设计模式全面解析](http://c.biancheng.net/design_pattern/)
* [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)
* [为什么我们需要学习（设计）模式](https://zhuanlan.zhihu.com/p/19835717)