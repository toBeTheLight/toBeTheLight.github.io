---
layout: post
title:  "阅读：《算法》"
categories: 阅读笔记 算法
tags:  算法
author: toBeTheLight
---

* content
{:toc}





## 基础


* 递归
  * 递归总有一个最简单的情况，即递归结束。
  * 递归调用总是去尝试解决一个规模更小的子问题，至逐渐收敛至最简单的情况。
  * 递归的父问题和尝试解决的子问题之间无交集，可以理解为操作部分不同。

* 数据结构：相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合
  * 存储结构：顺序存储、链式存储等
  * 逻辑结构：线性结构（栈、队列等）、图、二叉树等
* 算法：一组操作的方式

- 研究抽象数据类型的一个重要类型是控制数据结构的复杂度。

* 数据类型
  * Bag
  * Queue
  * Stack
    * 算术表达式求值应用：妙呀！
  * List

* 算法分析
  * 算法耗时
    * 每条语句的耗时
      * 由计算机性能决定
    * 每条语句的频率
      * 于是频率就成了关键
      * 在一般的频率表达式中一般忽略较小的项，使用~表示，如 N^3/6-N^2/2+N/3，则忽略-N^2/2+N/3
      * g(N)~f(N)表示g(N)/f(N)随着N的增大趋近于1，同时将f(N)成为g(N)增长的数量级
  * 通常的步骤
    1.  确定输入模型，明确问题规模
    2.  识别内循环
    3.  根据内循环中的操作确定成本模型（即算法的基本操作，如常见排序算法内循环中的对数组元素的访问次数）
    4.  判断这些操作的执行频率，确定成本模型的增长数量级
    5.  需要注意的是某些大常数系数、内循环外的大量指令可能对增长造成不可忽略的影响
  * 常见数量级
    * 常数：1
    * 对数：logN
    * 线性：N
    * 线性对数：NlogN
    * 平方：N^2
    * 立方：N^3
    * 指数：a^N
  * 内存评估
    * 略
  * 算法优化
    * 完整而详细的定义问题，找出解决问题所必需的基本抽象操作并定义一份API
    * 简洁的实现
    * 评估实现所能解决的问题的最大规模是否满足预期，是否可改进或另做实现
    * 逐步改进实现，通过**经验**性分析或数学分析验证改进后的效果
      * 用更高层次的抽象表示数据结构或算法来设计更高级的改进版本
      * 为最坏情况下的性能提供保证时处理普通数据时也要保证普通数据的性能


## 排序

部分排序实现见 demo

* 二叉树性质：
  * 组合学性质：高度为 h 的最多只可能有 2^h 个叶子结点，拥有 2^h（1* h 个 2） 个结点的树是完美平衡树。

* 归并排序和快速排序的区别
  * 归并排序是局部有序到整体有序。
  * 快拍是整体部分有序（一侧小于基准值，一侧大于基准值）到所有局部部分有序（局部够小时则达到局部完全有序），从而使整体完全有序。

* 堆排序
  * 优先队列：优先队列适用于不需要全部有序的场景下（如只需要知道队列里最高优先级的任务是什么）
    * 基本操作：删除的最大元素、插入元素
  * 堆：
    * 某个结点的值总是不大于（为最大堆）或不小于（为最小堆）其父结点
    * 是一颗完全二叉树
    * 堆的根结点是堆有序的二叉树（都有序的二叉树）
  * 二叉堆数据结构是优先队列的一种实现方式
  * 二叉堆表示法：将堆从上到下，从左到右排进数组（从索引 1 开始），则结点 k 的子结点位置为 2k 和 2k + 1，节点 g 的父结点为 g/2。利用这一特征可以灵活高效实现优先队列
  * 算法：
    * 上浮 swim：结点由下到上进行堆有序化的过程
      * 不停向上交换结点与比他小（最大堆）或比他大（最小堆）的父结点的位置
      * 应用：插入新结点时，可将新结点 push 到数组的最后，与 index/2 比较交换位置
    * 下沉 sink：结点由上到下进行堆有序化的过程
      * 找到所有子节点中比自己大的最大的子节点（最大堆）或比自己小的最小的子节点（最小堆），并与他交换位置
      * 应用：队列根结点剔除后，将最后的结点交换至首位，进行下沉操作使得堆重新有序
  * 利用二叉堆根结点是极值结点（主Key最大或最小的结点）这一特性可以实现排序算法，称之为堆排序算法
    1. 对数据创建二叉树结构（根据表现那条，数组是堆的表现，即二叉树的表现，所以此步有时可以省略）
    2. 使用 sink 循环进行堆有序化（小堆有序后，其父结点再次 sink，则更高一层的堆也会有序，由于叶子结点不需要排序，根据表示法来说，最后一个非叶子结点的索引为 length/2，利用这一推论对堆的有序化可以从倒数第二层开始，即 length/2、lenght/2-1、length/2-2 循环至根结点 1，则二叉树堆有序化完成成为堆）
    3. 将堆的根结点（极值点）提出，对剩余结点组成的失序的二叉树进行重新有序化（参考 sink 的应用），则根结点重新成为极值点
    4. 循环步骤 3 至所有结点都被提出，则排序完成