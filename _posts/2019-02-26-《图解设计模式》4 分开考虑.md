---
layout: post
title:  "阅读：《图解设计模式》4 分开考虑"
categories: 阅读笔记 设计模式
tags:  设计模式 桥接模式 策略模式
author: toBeTheLight
---

* content
{:toc}
书中将 Bridge 桥接模式、Strategy 策略模式归纳为用来分解易变得杂乱无章的处理的设计模式。
* 桥接模式：将类的功能和实现分离，功能接口通过组合关系使用实现类来完成具体实现。
* 策略模式：





## Bridge 桥接模式

### 定义

桥接模式是将类的功能层级结构与它的实现层次结构**分离**，使它们都可以独立地变化。

* 功能层级结构：对接口的扩展（方法的扩展）。
* 实现层级结构：对接口的实现（在这种模式下一般实现时不进行扩展）。

### 角色

* 功能化：即功能层级结构的最顶级的类（书中叫抽象化，但此抽象化的“抽象”和抽象类的“抽象”没有关系，一般不含有抽象方法）。
* 改善后的功能化：扩展了功能化的方法（同样书中叫改善后的抽象化）。
* 实现者：即实现层级结构的最顶级的类，也正是由此，其为抽象类。
* 具体实现者：对实现者类方法的实现。

### JavaScript 实现

例子不太好想。借用书中的 Java 例子。

```js
// 功能化类：
class Display {
  constructor (impl) {
    this.impl = impl
  }
  open () {
    this.impl.rawOpen()
  }
  print () {
    this.impl.rawPrint()
  }
  close () {
    this.impl.rawClose()
  }
  display () {
    this.open()
    this.print()
    this.close()
  }
}
// 改善后的功能化，扩展了 multiDisplay 方法
class CountDisplay extends Display {
  constructor (impl) {
    super(impl)
  }
  multiDisplay (times) {
    this.open()
    for (let i = 0; i < times; i++) {
      this.print()
    }
    this.close()
  }
}
// 还可以有其他扩展
//...

// 实现者，可以看出，位于实现结构最顶层的实现者类才是抽象类
class DisplayImpl {
  rawOpen () {
    throw new Error('需实现 DisplayImpl 类的 rawOpen 方法')
  }
  rawPrint () {
    throw new Error('需实现 DisplayImpl 类的 rawPrint 方法')
  }
  rawClose () {
    throw new Error('需实现 DisplayImpl 类的 rawClose 方法')
  }
}
// 具体实现者
class StringDisplayImpl extends DisplayImpl {
  constructor (text) {
    super()
    this.text = text
  }
  rawOpen () {
    console.log('----------')
  }
  rawPrint () {
    console.log(this.text)
  }
  rawClose () {
    console.log('----------')
  }
}
// 还可以有其他实现
//...

// 使用者
const impl = new StringDisplayImpl('Hello, Bridge')
const countDisplay = new CountDisplay(impl)
countDisplay.multiDisplay(3)
```

### 思考

## Strategy 策略模式

### 定义

### 角色

### JavaScript 实现

### 思考

### 扩展