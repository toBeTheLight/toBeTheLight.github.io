---
layout: post
title:  "阅读：《认知觉醒》"
categories: 阅读笔记
tags:  方法论 心理学
author: toBeTheLight
---

* content
{:toc}








# 区块链

以比特币白皮书来说，P2P 账本，每一个节点都会向周围节点广播交易信息，在共识机制（PoW 工作量证明，还有其他如 PoS、DPoS 机制）下，一些节点获取到向区块链中写入交易信息（即记账）的权限，将收到的交易信息计算为新的区块，广播至周围节点，其它节点校验并接受后追加到链上，从而形成区块链。

* 结构：区块链数据结构：区块+链。
    * 区块：
        * 区块体：
            * 存储实际数据，即账本信息（如交易信息）等
            * 上层结点对下层结点的内容或哈希值（一般只有叶子结点才存实际数据，非叶子结点只存哈希值）求哈希值
            * 哈希值向上逐层关联形成哈希树（即 Merkle Tree， 或变种）结构
        * 区块头：负责基本功能，一般包含以下部分
            * 用前一个区块的区块头信息求得的哈希
            * 时间戳
            * 哈希树的根哈希
            * 等
    * 链：新的区块通过区块间哈希关联，追加到旧的区块后面，形成链
* 防篡改：
    * 链：由于新区块的区块头中包含对上个区块的区块头的哈希求值，依次向前，使得整个区块链如果某个区块信息被篡改则需要修改后续所有区块，在健康的区块链中篡改难度很高
    * 单个块：区块头中存在以某种方式对区块体信息计算出的总哈希（哈希树的根哈希），所以篡改单个区块中的信息会使得根哈希与内容不匹配，则需要对根哈希篡改，对存在在区块头的根哈希篡改则会导致整个链中区块间哈希不匹配，从而防止篡改

## 比特币

比特币区块的区块体中以哈希树的结构存储了新发生的每笔交易。

交易信息示例：
```
// 输入
In:
Previous tx: f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b009ca73dd0
4470b9a6
Index: 0
// Previous tx + Index 指向某笔交易的某个输出，应为某个未使用的交易输出
scriptSig: 304502206e21798a42fae0e854281abd38bacd1aeed3ee3738d9e1446
618c4571d1090db022100e2ac980643b0b82c0e88ffdfec6b64e3e6ba35e7ba5fd
d7d5d6cc8d25c6b241501  // scriptSig 需要可解资金来源记录的 scriptPubKey

// 输出
Out:
Value: 5000000000 // 金额
scriptPubKey: OP_DUP OP_HASH160 404371705fa9bd789a2fcd52d2c580b65d35
549d OP_EQUALVERIFY OP_CHECKSIG // 解锁脚本，下一个交易的 scriptSig 使得 scriptPubKey 通过则可使用此笔交易
```

同时引入一个概念，叫 UTXO，即未使用的交易输出，即未被之后的交易使用的向某地址的某次比特币输出，由之前的交易信息计算获得，用于后续发生的交易的校验。

* 交易信息：每笔交易以之前的交易记录为基础，需要满足输入等于输出
    * 示例：A 账号要支付 6 比特币给 D 账号，则交易数据写为：
        * 输入：B 账号支付 2 比特币给 A 账号 + C 账号支付 3 比特币给 A 账号 + D 账号支付 2 比特币给 A 账号
        * 输出：支付 6 比特币给 D 账号 + 支付 1 比特币给 A 账号
    * 特点：
        * 需要说明支出的来源（也可直接指向某历史支出）
        * 单笔交易输出无法拆分，以找零形式（即支付给自己）解决数额的不匹配
* 交易信息确权：如何确认 UTXO 的所有权
    * 发送节点发出的交易信息包含
        * 1个或多个交易引用（即本次交易的比特币来源，即之前的交易信息中的未被使用的交易输出）
        * 对应交易输出的解锁脚本（有公钥）
    * 接收节点：
        * 将解锁签名和对应交易输出包含的锁定脚本拼接后以栈结构执行
        * 执行通过，则可使用这些未使用的交易输出
        * 即，公钥提供者有有这些未使用的交易输出的使用权
* 交易信息防伪：如何对交易信息防伪，使用非对称加密对信息进行签名
    * 发送节点：
        * 对交易信息哈希获得一个摘要
        * 用发送节点的私钥对摘要加密生成签名
        * 将内容和签名进行广播（签名也在解锁脚本里）
    * 接收节点：
        * 在执行脚本的过程中
        * 使用发送节点交易信息中的公钥对签名解密得到摘要 1
        * 对内容进行哈希，得到摘要 2
        * 摘要 1 等于摘要 2 则公钥、私钥匹配，内容可信
        * 即交易信息是解锁这个交易输出的公钥的对应真实私钥拥有者写的
* 交易信息进链：分布式、一致性、维护
    * 分布式：
        * 网络上很多节点进行存储和数据认证
        * 发送节点向周围节点广播交易信息
        * 每个节点都保存了区块链的完整或部分数据
    * 有效性：如某账号同时发送了多条矛盾的交易信息
        * 矿工将收到的交易信息与区块中的验证后开始制作为新的区块
        * 也可以不在区块中记录交易信息就制作区块（空块问题）
    * 一致性：由于广播问题，单位时间内矿工们收到即交易信息可能不同，制作的区块内容可能不同，如果都要上链则会造成最终生成的区块信息不一致
        * PoW：使用共识规则让单位时间内（约10分钟）只有一个矿工能将自己的区块发布到链上
        * 规则：
            1. 将新区块的内容（前一个区块的SHA-256 + 这个区块的基本信息 + 新区块的交易信息）组合成字符串
            2. 在新区块字符串的末尾加上一个随机数，进行SHA-256，如果结果的二进制前 72 位全是 0 则工作完成，这是一个工作量巨大的碰运气工作
            3. 随着整体算力的提高会提升难度（增加 0的数量等）将出块时间稳定在 10 分钟
        * 所以挖矿需要大量的算力（耗电）
        * 矿工收入：
            * 比特币网络奖励：写入对自己地址进行 6.25 个比特币输出的奖励交易（Coinbase Newly Generated Coins）信息，此奖励每过 21 万个区块减半，也是比特币的发币方式
            * 区块中的交易手续费：区块中所有输入和输出金额的差值，由矿工写给自己
    * 分叉：凑巧同时生成了两个区块，则两个块都会并列入链，形成临时分叉，在后续计算中采用最长链原则，废弃追加区块数量少的分叉
    * 交易确认：正是因为分叉的存在，所以交易一般需要在继续追加多个区块后才会被确认
    * 篡改：需要有超高的算力，篡改者的算力需要超过整个网络的算力才能实现篡改，才会使得自己的篡改分叉变成最长链，完成篡改

### 总结

1. 使用 SHA-256 算法和非对称加密制作数字签名进行防伪
2. 执行交易信息中的脚本验证验证签名
3. 使用区块链的区块存储比特币交易信息，使用哈希树存储并防止交易数据篡改
4. 利用额外的工作规则达成网络一致性（拼算力）
5. 将网络奖励和交易手续费支付给矿工节点

## 以太坊

以太坊黄皮书

> https://ethereum.github.io/yellowpaper/paper.pdf

以太坊整体上可以看成是一个基于交易的状态机；支持智能合约，可编程的区块链，一种平台。去中心化应用。

### 

* 区块头：
    * parentHash：前一区块区块头计算哈希
    * ommersHash：叔块，无效的区块，也可以获得部分奖励，往前查七代，很有意思的抑制临时分叉的方式
    * beneficiary：与比特币不同的是，以太坊的挖块奖励写在区块头
    * stateRoot：状态树根哈希
    * transactionsRoot：交易树根哈希
    * receiptsRoot：收据树根哈希
    * logsBloom：收据数据Bloom 过滤器，一种判断信息是否存在的不准的算法
    * 等

与比特币不同的是，以太坊的区块体中有三棵树：状态树、交易树、收据树。

* 区块体:
    * 状态树：树的主体并不保存在区块链中，而是以以下结构存在节点的本地数据库中
        * 一种变种压缩前缀哈希树（Merkle Patricia Tree，MPT）
        * 存储了所有已知的账户的状态（即发生过交易的账户，由叶子结点存储）
            * 外部账户：钱包，无代码，能转账或执行智能合约
            * 合约账户：创建合约时生成，存有代码，能被触发执行智能合约
            * 状态：
                * nonce：地址的交易数量或合约数量
                * balance：余额
                * storageRoot：账户内容（ MPT 树）的根哈希
                * codeHash：合约账户的代码的哈希，外部账户没有
        * 新区块只会实际存储发生变化的账户的状态，未发生变化的会指向之前的区块状态树的对应位置
    * 交易树：驱动状态树发生变更，也是 MPT
        * 消息调用
        * 合约账户创建
    * 收据树：也是 MPT
        * 交易执行过程中的特定信息编码为交易数据，保存在一个索引为键的树中
        * 交易过程中创建的日志会构成区块头的 Bloom 过滤器

## 其他

* 空块：在部分区块链中，新区块产生后，会先广播区块头再广播区块体，由于区块体数据较大，下载需要时间，部分矿工节点会在收到区块头后就开始挖矿，由于向新区块体中写入的交易信息不能与已有区块冲突或重复，所以为保证在未拿到前一区块信息的情况下的新区块的有效性，不向新区块体中写入实际交易信息（奖励信息除外），从而产生空块。

## 参考资料

* https://www.youtube.com/watch?v=obRzfcvMshM&feature=youtu.be
