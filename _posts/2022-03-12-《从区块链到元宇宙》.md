---
layout: post
title:  "阅读：《认知觉醒》"
categories: 阅读笔记
tags:  方法论 心理学
author: toBeTheLight
---

* content
{:toc}








# 区块链

以比特币白皮书来说，P2P 账本，每一个节点都会向周围节点广播交易信息，在共识机制（PoW 工作量证明，还有其他如 PoS、DPoS 机制）下，一些节点获取到向区块链中写入交易信息（即记账）的权限，将收到的交易信息计算为新的区块，广播至周围节点，其它节点校验并接受后追加到链上，从而形成区块链。

系统中所有结点做相同的操作维护一个相同的状态机的分布式系统。

* 结构：区块链数据结构：区块+链。
    * 区块：
        * 区块体：
            * 存储实际数据，即账本信息（如交易信息）等
            * 上层结点对下层结点的内容或哈希值（一般只有叶子结点才存实际数据，非叶子结点只存哈希值）求哈希值
            * 哈希值向上逐层关联形成哈希树（即 Merkle Tree， 或变种）结构
        * 区块头：负责基本功能，一般包含以下部分
            * 用前一个区块的区块头信息求得的哈希
            * 时间戳
            * 哈希树的根哈希
            * 等
    * 链：新的区块通过区块间哈希关联，追加到旧的区块后面，形成链
* 防篡改：
    * 链：由于新区块的区块头中包含对上个区块的区块头的哈希求值，依次向前，使得整个区块链如果某个区块信息被篡改则需要修改后续所有区块，在健康的区块链中篡改难度很高
    * 单个块：区块头中存在以某种方式对区块体信息计算出的总哈希（哈希树的根哈希），所以篡改单个区块中的信息会使得根哈希与内容不匹配，则需要对根哈希篡改，对存在在区块头的根哈希篡改则会导致整个链中区块间哈希不匹配，从而防止篡改

## 比特币

比特币区块的区块体中以哈希树的结构存储了新发生的每笔交易。

交易信息示例：
```
// 输入
In:
Previous tx: f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b009ca73dd0
4470b9a6
Index: 0
// Previous tx + Index 指向某笔交易的某个输出，应为某个未使用的交易输出
scriptSig: 304502206e21798a42fae0e854281abd38bacd1aeed3ee3738d9e1446
618c4571d1090db022100e2ac980643b0b82c0e88ffdfec6b64e3e6ba35e7ba5fd
d7d5d6cc8d25c6b241501  // scriptSig 需要可解资金来源记录的 scriptPubKey

// 输出
Out:
Value: 5000000000 // 金额
scriptPubKey: OP_DUP OP_HASH160 404371705fa9bd789a2fcd52d2c580b65d35
549d OP_EQUALVERIFY OP_CHECKSIG // 解锁脚本，下一个交易的 scriptSig 使得 scriptPubKey 通过则可使用此笔交易
```

同时引入一个概念，叫 UTXO，即未使用的交易输出，即未被之后的交易使用的向某地址的某次比特币输出，由之前的交易信息计算获得，用于后续发生的交易的校验。

* 交易信息：每笔交易以之前的交易记录为基础，需要满足输入等于输出
    * 示例：A 账号要支付 6 比特币给 D 账号，则交易数据写为：
        * 输入：B 账号支付 2 比特币给 A 账号 + C 账号支付 3 比特币给 A 账号 + D 账号支付 2 比特币给 A 账号
        * 输出：支付 6 比特币给 D 账号 + 支付 1 比特币给 A 账号
    * 特点：
        * 需要说明支出的来源（也可直接指向某历史支出）
        * 单笔交易输出无法拆分，以找零形式（即支付给自己）解决数额的不匹配
* 交易信息确权：如何确认 UTXO 的所有权
    * 发送节点发出的交易信息包含
        * 1个或多个交易引用（即本次交易的比特币来源，即之前的交易信息中的未被使用的交易输出）
        * 对应交易输出的解锁脚本（有公钥）
    * 接收节点：
        * 将解锁签名和对应交易输出包含的锁定脚本拼接后以栈结构执行
        * 执行通过，则可使用这些未使用的交易输出
        * 即，公钥提供者有有这些未使用的交易输出的使用权
* 交易信息防伪：如何对交易信息防伪，使用非对称加密对信息进行签名
    * 发送节点：
        * 对交易信息哈希获得一个摘要
        * 用发送节点的私钥对摘要加密生成签名
        * 将内容和签名进行广播（签名也在解锁脚本里）
    * 接收节点：
        * 在执行脚本的过程中
        * 使用发送节点交易信息中的公钥对签名解密得到摘要 1
        * 对内容进行哈希，得到摘要 2
        * 摘要 1 等于摘要 2 则公钥、私钥匹配，内容可信
        * 即交易信息是解锁这个交易输出的公钥的对应真实私钥拥有者写的
* 交易信息进链：分布式、一致性、维护
    * 分布式：
        * 网络上很多节点进行存储和数据认证
        * 发送节点向周围节点广播交易信息
        * 每个节点都保存了区块链的完整或部分数据
    * 有效性：如某账号同时发送了多条矛盾的交易信息
        * 矿工将收到的交易信息与区块中的验证后开始制作为新的区块
        * 也可以不在区块中记录交易信息就制作区块（空块问题）
    * 一致性：由于广播问题，单位时间内矿工们收到即交易信息可能不同，制作的区块内容可能不同，如果都要上链则会造成最终生成的区块信息不一致
        * PoW：使用共识规则让单位时间内（约10分钟）只有一个矿工能将自己的区块发布到链上
        * 规则：
            1. 将新区块的内容（前一个区块的SHA-256 + 这个区块的基本信息 + 新区块的交易信息）组合成字符串
            2. 在新区块字符串的末尾加上一个随机数，进行SHA-256，如果结果的二进制前 72 位全是 0 则工作完成，这是一个工作量巨大的碰运气工作
            3. 随着整体算力的提高会提升难度（增加 0的数量等）将出块时间稳定在 10 分钟
        * 所以挖矿需要大量的算力（耗电）
        * 矿工收入：
            * 比特币网络奖励：写入对自己地址进行 6.25 个比特币输出的奖励交易（Coinbase Newly Generated Coins）信息，此奖励每过 21 万个区块减半，也是比特币的发币方式
            * 区块中的交易手续费：区块中所有输入和输出金额的差值，由矿工写给自己
    * 分叉：凑巧同时生成了两个区块，则两个块都会并列入链，形成临时分叉，在后续计算中采用最长链原则，废弃追加区块数量少的分叉
    * 交易确认：正是因为分叉的存在，所以交易一般需要在继续追加多个区块后才会被确认
    * 篡改：需要有超高的算力，篡改者的算力需要超过整个网络的算力才能实现篡改，才会使得自己的篡改分叉变成最长链，完成篡改

### 总结

1. 使用 SHA-256 算法和非对称加密制作数字签名进行防伪
2. 执行交易信息中的脚本验证验证签名
3. 使用区块链的区块存储比特币交易信息，使用哈希树存储并防止交易数据篡改
4. 利用额外的工作规则达成网络一致性（拼算力）
5. 将网络奖励和交易手续费支付给矿工节点

## 以太坊

以太坊黄皮书

> https://ethereum.github.io/yellowpaper/paper.pdf

以太坊整体上可以看成是一个基于交易的状态机；支持智能合约，可编程的区块链，一种平台。去中心化应用。

### 结构

* 区块头：
    * parentHash：前一区块区块头计算哈希
    * ommersHash：叔块，无效的区块，也可以获得部分奖励，往前查七代，很有意思的抑制临时分叉的方式
    * beneficiary：与比特币不同的是，以太坊的挖块奖励写在区块头
    * stateRoot：状态树根哈希
    * transactionsRoot：交易树根哈希
    * receiptsRoot：收据树根哈希
    * logsBloom：收据数据Bloom 过滤器，一种判断信息是否存在的不准的算法
    * gasLimit：区块汽油费上限，由矿工们共同维护
    * 等

与比特币不同的是，以太坊的区块体中有三棵树：状态树、交易树、收据树。

* 区块体：树的主体并不保存在区块链中，而是以以下结构存在节点的本地
    * 状态树：
        * 一种变种压缩前缀哈希树（Merkle Patricia Tree，MPT）
        * 存储了所有已知的账户的状态（即发生过交易的账户，由叶子结点存储）
            * 外部账户：钱包，无代码，能转账或执行智能合约
            * 合约账户：创建合约时生成，存有代码，能被触发执行智能合约
            * 状态：
                * nonce：地址的交易数量或合约数量
                * balance：余额
                * storageRoot：账户内容（ MPT 树）的根哈希
                * codeHash：合约账户的代码的哈希，外部账户没有
        * 新区块只会实际存储发生变化的账户的状态，未发生变化的会指向之前的区块状态树的对应位置
    * 交易树：驱动状态树发生变更，也是 MPT，只保存区块中发生的交易信息
        * 消息调用
        * 合约账户创建
    * 收据树：也是 MPT
        * 交易执行过程中的特定信息编码为交易数据，保存在一个索引为键的树中
        * 交易过程中创建的日志会构成区块头的 Bloom 过滤器

## PoW

区块块头加 nonce 算哈希，映射至大数据集（由一个seed生成的小数据集生成），读取映射位置和相邻位置的元素，再哈希，循环 64 次，算出一个哈希和挖矿目标值对比。

失败则更换区块头中 nonce 重新计算。

## 智能合约

### 调用

外部账户调用合约账户，外部账户发起的合约账户调用也可以调用另一个合约账户。

外部账户调用时，将目标函数和参数写在 data 域中，向合约账户发起交易。

合约调用合约的一种方式：
```Solidity
contract A {
    event LogCallFoo (string str);
    function foo (string str) returns (uint) {
        emit LogCallFoo(str);
        return 123;
    }
}

contract B {
    uint ua; // callAFooDirectly 的执行返回值
    function callAFooDirectly (address addr) public {
        A a = A(addr);
        ua = a.foo("call foo directly);
    }
}
```

### 创建和运行

* 智能合约代码编写（solidity 等）完之后，编译成 bytecode
* 创建：外部账户向 0*0 地址发起交易，将代码放在 data 域中
* 智能合约运行在 EVM 中
* 调用智能智能合约的交易发布到区块链上后，所有矿工都会执行这个交易使得，状态树发生变更
* 发起调用的账户需要支付汽油费 GasLimit
    * 执行前全额扣除，开始执行，多退少补，不够则状态回滚，汽油费不退
    * 执行出错则状态回滚，汽油费不退
* 每个交易执行之后形成一个收据，存有执行结果等信息

### 一个例子

```Solidity
contract SimpleAuctionV1 {
    address public beneficiary; // 受益人
    uint public auctionEnd; // 结束时间
    address public highestBidder; // 当前最高出价地址
    mapping(address => unit) bids; // 所有出价
    address[] bidders; // 所有出价地址
    bool ended; // 是否结束

    event HighestBidIncreased(address bidder, uint amount);
    event AuctionEnded(address winner, unit amount);

    constructor(uint _biddingTime, address _beneficiary) public {
        beneficiary = _beneficiary;
        auctionEnd = now + _biddingTime
    }
}
// 参与拍卖的地址向此合约地址发起交易并支付货币
function bid() public payable {
    require(now <= auctionEnd);
    require(bids[msg.sender]+msg.value > bids[highestBidder]);

    if (!(bids[msg.sender] == unit(0))) {
        bidders.push(msg.sender);
    }
    highestBidder = msg.sender;
    bids[msg.sender] += msg.value;
    emit HighestBidIncreased(msg.sender, bins[msg.sender]);
}
// 拍卖结束
function auctionEnd()public {
    require(now > auctionEnd);
    require(!ended);
    beneficiary.transfer(bids[highestBidder]);
    for (uint i = 0; i< bidders.length; i++) {
        address bidder = bidders[i];
        if (bidder == highestBidder) continue;
        bidder.transfer(bids[bidder]);
    }

    ended = true;
    emit AuctionEnded(highestBidder, bids[highestBidder]);
}
```

这里存在一个问题：`beneficiary.transfer`，如果 beneficiary 是一个无法接受支付的合约地址，那么会导致 `auctionEnd` 执行失败，导致所有出价锁在智能合约地址中，永远无法取出。

除此之外还有重入攻击，即调用的合约账户可能会在调用中反过来调用，引发循环执行。

> Code Is Law：智能合约的逻辑由代码决定，已发布的合约代码无法修改，就算有 Bug 也无法修改。

The DAO（Decentralized Autonomous Organization）：利用了重入攻击，转走了 5000万/1.5亿美元的以太币，造成了以太坊的硬分叉 ETH、ETC。

## NFT

基于智能合约，每个人可以在智能合约账户内部维护一个状态树，NFT 正是这样的一种应用，全称为非同质化代币。

NFT 的一大特征是，公开且防篡改的确定了某地址对某个数字作品的所有权。

一个 ERC721 标准（一种以太坊上发行 NFT 的标准）的 NFT 在区块链的数据示例：
* 地址：0x40468d172cE354d3fAdAb06D0FA53eDdB2F3AA45
* id：6
* tokenURI：https://Opensea-creatures-api.herokuapp.com/api/creature/6）

表明某地址拥有某个编号的某个物品。大多数 NFT 的实现上看，在区块链上只是记录了一个作品拥有者的地址、作品的编号、以及这个作品的链接，而作品本身在链下，所以也出现过现实中的作品被他人铸造成 NFT 出售的情况。

通过调用智能合约的函数，可以进行 NFT 的转移、交易。所以可以知道，NFT 不单指某一个代币，而是一种代币类型，你也可以通过创建自己的智能合约，发行自己的 NFT 或 NFT 平台。

同时，由于 https 的内容会被修改，一般会用 IPFS 代替（分布式文件存储系统）。

## 元宇宙

区块链应该会是元宇宙的一部分实现技术，在对于可任意复制的数字世界的数字资产进行确权的基础，如现有的 Decentraland 的虚拟土地、NFT、创造品的售卖。

## 总结

* 区块链存在交易速度慢、耗能高的问题，但要结合场景观测，在具体的场景下是比现有的解决方案快的，如跨国转账。
* 智能合约：代码合同虽然不是一般人可以看懂的，但程序化是一个大趋势。

## 其他

* 空块：在部分区块链中，新区块产生后，会先广播区块头再广播区块体，由于区块体数据较大，下载需要时间，部分矿工节点会在收到区块头后就开始挖矿，由于向新区块体中写入的交易信息不能与已有区块冲突或重复，所以为保证在未拿到前一区块信息的情况下的新区块的有效性，不向新区块体中写入实际交易信息（奖励信息除外），从而产生空块。

## 参考资料

* https://www.youtube.com/watch?v=obRzfcvMshM&feature=youtu.be
* https://www.bilibili.com/video/BV1Vt411X7JF
* https://blog.csdn.net/vigor2323/article/details/122711205