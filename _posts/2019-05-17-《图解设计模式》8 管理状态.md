---
layout: post
title:  "阅读：《图解设计模式》7 管理状态"
categories: 阅读笔记 设计模式
tags:  设计模式 观察者模式 备忘录模式 状态模式
author: toBeTheLight
---

* content
{:toc}
书中将 Observer 观察者模式、Memento 备忘录模式、State 状态模式归纳为状态相关的设计模式。
观察者模式：观察对象管理听他的所有观察者，并在发生变化时通知所有观察者。
备忘录模式：
状态模式：





## Observer 观察者模式

### 定义

观察对象管理听他的所有观察者，并在发生变化时通知所有观察者。

### 角色

* 抽象观察目标：定义或实现了注册观察者、删除观察者、通知观察者等方法。
* 具体观察目标：实现抽象观察目标接口。
* 抽象观察者：定义了接收观察目标状态变化的接口。
* 具体观察者：实现抽象观察者接口。

### JavaScript 实现

```js
// 抽象观察目标
class Subject {
  constructor ({ value }) {
    this.value = value || 0
    this.observers = []
  }
  add (observer) {
    this.observers.push(observer)
  }
  notify (...args) {
    this.observers.forEach((observer) => observer.update(this, ...args))
  }
  getValue () {
    return this.value
  }
}
// 具体观察目标
class Data extends Subject {
  constructor ({ value }) {
    super({ value })
  }
  run () {
    while(this.value < 10) {
      this.value += 1
      this.notify(Date.now())
    }
  }
}
// 抽象观察者
class Observer {
  constructor () {
  }
  update () {
    throw new Error('需实现 Observer 类的 update 方法')
  }
}
// 具体观察者
class TimeObserver extends Observer {
  update (subject, time) {
    console.log(time, subject.getValue())
  }
}
class StepObserver extends Observer {
  constructor () {
    super()
    this.lastTime = 0
  }
  update (subject, time) {
    const step = this.lastTime === 0 ? 0 : time - this.lastTime
    this.lastTime = time
    console.log(step, subject.getValue())
  }
}
// 使用
const data = new Data(2)
data.add(new TimeObserver())
data.add(new StepObserver())
data.run()
```

### 思考

* 模式对比：
  * 与**中介者模式**类似的是，都通过消息推送的方式通知动作。不同的是，中介者模式是多个子对象向中介者对象推送消息，由中介者协调调用目标子对象；而在订阅者模式中是一个被观察对象向它的多个观察者推送消息。
  * 在经典的观察者模式（如同实现代码）之上还延伸出了发布订阅模式，除观察者和被观察者之外，还存在一个接收和消费消息的消息中心，由它来连接观察者和订阅者，可以保证没有观察者和被观察对象时，系统也能正确存在。在结构上来说，可以当做是经典观察者模式和中介者模式的结合。


## Memento 备忘录模式

### 定义

### 角色

### JavaScript 实现

### 思考
