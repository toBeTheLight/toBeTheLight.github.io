---
layout: post
title:  "从输入url按下回车开始能做哪些优化(未完)"
categories: Web性能
tags:  Web性能
author: toBeTheLight
---

* content
{:toc}




# 参考
* 《计算机网络自顶向下方法》
* 《Web性能权威指南》
* [老生常谈-从输入url到页面展示到底发生了什么](https://www.cnblogs.com/xianyulaodi/p/6547807.html)
* [what happens when you type in a URL in browser](https://stackoverflow.com/questions/2092527/what-happens-when-you-type-in-a-url-in-browser)
* [“天龙八步”细说浏览器输入URL后发生了什么](http://www.xuecaijie.com/it/157.html)
* [DNS解析的过程是什么，求详细的？](https://www.zhihu.com/question/23042131)
* [前端性能优化最佳实践](https://csspod.com/frontend-performance-best-practices/)

# DNS 域名解析

一般来讲，我们输入的url是域名，而为了识别一个实体，TCP/IP使用IP地址来唯一确定一台主机到因特网的连接，DNS会帮助我们完成域名到IP地址映射的工作。以`www.aaa.com`为例，解析过程大致如下：

## 过程

* 浏览器
  * 浏览器查询浏览器缓存，没有。

* 本机层
  * 浏览器客户端向系统询问服务器IP地址，调用本机内的DNS解析程序，检查自己本地的hosts文件是否有这个域名映射关系，没有。
  * 查找本机的DNS解析器缓存，没有。

* 路由器缓存
  * 可能还存在路由器缓存这一层

* 本地DNS服务器
  * 本机的DNS解析程序向本地的DNS服务器发起请求，一般为TCP/IP参数中设置的首选DNS服务器，是知道IP地址的，一般会UDP协议。
  * 本地DNS服务器查询是否在本地区域文件中，没有。
  * 本地DNS服务器查询DNS缓存中是否存在，没有。
  * 本地DNS服务器会根据是否设置转发器判断是向上一级DNS服务器（其解析规则同理）还是直接向根DNS服务器（知道根DNS服务器的IP地址）发送请求。

* 与DNS服务器
  * 收到请求后，根DNS服务器并不直接解析地址，但是知道每个顶级域中的一台服务器的地址（如com 域名服务器）。如果为迭代查询方式，此顶级域DNS服务器的ip被返回给本地DNS服务器。
  * 本地DNS服务器提取到顶级域DNS服务器信息后，会再向其发出请求。顶级域DNS服务器收到请求后，会先查询自己的缓存，没有，则将负责的二级域名服务器（如aaa.com域名服务器）返回给本地DNS服务器，以此类推直到查到目标域名的映射信息或查询失败。
  * 查到映射信息后返回回到本机，中间各层会进行缓存。

* 查询方式：
  * 递归方式：一路查下去中间不返回，得到最终结果才返回信息。
  * 迭代方式：就是上面的本地DNS服务器与其他域名服务器直接的查询方式。
  * 一般默认的方式从本机到本地DNS服务器是递归，DNS服务器之间是迭代查询。

## 优化

当然针对DNS的优化就是减少DNS解析的时间，由于浏览器缓存机制的存在，我们只需要对首次访问进行优化（虽然我们现在只是请求了一个html文件，但是html文件里还会有我们后续要请求的css/js/img等），即适当减少要解析的域名个数，考虑到**其他优化机制**可以将页面及页面内外联资源发布到2-4个域名上。

# 建立连接

## TCP连接

好了，浏览器终于拿到服务器IP了，客户端想要与服务器间通信并传递消息需要开启TCP（一种传输层协议）连接。

### 过程

  * 客户端创建socket，向服务器目标端口发送连接建立请求，数据段包含位码SYN（建立联机标志位） = 1，随机数seq（顺序号码）= x，和其他TCP标志和选项。
  * 服务器有一个专门处理连接请求的welcome socket，接收到连接建立请求，置位码SYN和ACK（确认标志位）为1，ack（确认号码）= x + 1，随机数seq = y，并返回。
  * 客户端检查ack是否等于x + 1，等于时，将ACK置为1，SYN置为0，将ack置为y + 1发送至服务器端。
  * welcome socket检查ack等于y + 1和ACK等于1后，创建新的socket，此socket由源IP/源端口、目标IP/目标端口标识，之后客户端发送的数据都被引导向此新的socket，至此，TCP连接建立。

  简单来讲：

  ```
  // client: 
  send({SYN: 1, seq: x, ...others})
                      |
                      ↓
  //server: 
  send({SYN: 1, ACK: 1, ack: x + 1, seq: y, ...others})
                      |
                      ↓
  //client: 
  ack === x + 1 ? send({ACK: 1, SYN: 0, ack: y + 1, ...others}) : 'hehe'
                      |
                      ↓
  //server: 
  ack === y + 1 && ACK === 1 ? : new Socket()
  ```

## SSL/TLS

如果启用了HTTPS进行加密，在使用TLS传输前还需要协商建立加密信道。

### 过程

* 客户端：TCP连接建立之后，再以纯文本形式发送一些规格说明，随机数`Random1`，TLS协议版本，支持的加密套件列表，支持或希望使用的其他TLS选项。
* 服务器：
  1. 取得TLS协议版本以备将来通信使用，从客户端提供的加密套件列表中选择一个，生成随机数`Random2`发送给客户端；
  2. 附上自己的证书，将响应发送给客户端；
  3. 同时，也可发送一个请求，要求客户端提供证书以及其他TLS扩展参数。
* 客户端：
  1. 同上，可能会向服务器发送自己的证书。
  2. 客户端收到服务器的证书后，从CA（证书的签发机构）验证证书的合法性，验证通过后取出证书中的服务器公钥，生成随机数Random3，再用服务器公钥加密`Random3`（pre master key），发送给服务器；
  3. 告诉服务器可以开始加密透明信了；
  4. 客户端用`三个随机数`和`约定的加密方法`生成`对话密钥`。将前面的握手信息生成完成摘要，使用`对话密钥`加密，发送告诉服务器我已完成握手。
  * 除了服务器公钥加密的新对称密钥外，所有的数据都是明文形式发送。
* 服务器：
  * 用私钥解密出客户端发来的随机数，通过验证消息的MAC检测消息完整性，用相同的方式生成`对话密钥`。
  *  解密客户端发送的完成报文，验证`对话密钥`是否正确。
  1. 告诉客户端，要开始加密了；
  2. 同样再返回给客户端一个加密的完成消息。
* 客户端用它之前生成的`对话密钥`解密这条消息，确定`对话密钥是否正确`，正确则建立信道并且开始发送应用数据。

其中：
  * `对话秘钥`又可称为`协商秘钥`。
  * `对话秘钥`是对称秘钥，对称加解密速度很快。
  * 服务器公钥和私钥是非对称秘钥，非对称加解密速度很慢。
  * 带标号报文可能一次发送，也可能分开发送。
  * SSL和TLS可以当作一个东西。
  * 服务器也可以不使用CA颁发的证书，而使用自己的证书。

## 优化

目前使用的HTTP协议版本大多是1.1和2，由于两者有较大差别，我们需要分开讨论，其他更低版本不再做讨论。

与DNS部分优化相同，由于TCP握手耗时，和SSL/TLS更加耗时，我们需要减少需要建立的连接的次数（虽然我们现在只是请求了一个html文件，但是html文件里还会有我们后续要请求的css/js/img等）。  
针对HTTP1.1的最好方法是启用长连接：HTTP 1.1 提供了默认开启长连接功能，相对于短连接（每请求一个资源建立一次TCP连接），针对同一socket(域名+端口)后续请求都会复用一个TCP连接进行传输，直到关闭这个TCP连接。
