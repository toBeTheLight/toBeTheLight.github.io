---
layout: post
title:  "计算广告入门-索引布尔表达式"
categories: 其他技术
tags:  倒排索引 计算广告
author: toBeTheLight
---

* content
{:toc}






本文来自 [Indexing Boolean Expression](https://link.zhihu.com/?target=https%3A//theory.stanford.edu/~sergei/papers/vldb09-indexing.pdf) 部分，尽量以说人话的方式解释这种匹配布尔表达式的算法。

# 概念

* 倒排索引：Inverted Index，反向索引，根据内容查找文档记录
  * 如 `document1: { a: [1,2] }，document2: { a:[1], b: [9] }`
  * 建立倒排索引为 `a.1: [document1, document2], a.2: [document1]，b.1: [document2]`
  * 能快速找到到内容所在的文档记录
* 析取：Disjunctive，逻辑或
* 合取：Conjunctive，逻辑与，后文称为 且
* 析取范式：
  * （一个或多个且）的**或**被认为是一个 DNF
  * 如：(A)、(B) ∪ (C)、(D ∩ E) ∪ (F)
* 合取范式：
  * （一个或多个析取）的**且**被认为是一个 CNF
  * 如：(A)、(B) ∩ (C)、(D ∪ E) ∩ (F)
  * 所有逻辑公式都可以转换成合取范式

# 目标

快速查找目标所在的（布尔表达式：boolean expressions）匹配规则

# DNF 算法

先来匹配 DNF 表达式

1. 首先有几个匹配规则：
  * BE1：(a=1 且 b=2 且 c=1) 
  * BE2：(a=2 且 b=3) 或 c=1
  * BE3: (a=1 且 b!=2) 或 c=1
  * BE4：(a=1 且 b!=3)
  * BE5：b!=2
2. 有一个目标 s1，其属性为 a=1、b=3
3. 我们对所有的匹配规则建立倒排索引
  * 索引：
    * a=1：[BE1、BE3]
    * a=2：[BE2]
    * b=2：[BE1、BE3、BE4]
    * b=3：[BE2]
    * c=1：[BE2、BE3]
    * c=2: [BE1]
  * 为什么不建立索引 b!=2？非确切值无法进行匹配
4. 索引处理：
  * 使用 s1 在第 3 步的倒排索引中匹配的话我们只能找到包含 a=1 和 b=2 的所有文档，肯定是不符合目标的
  * 或拆分：在或关系中，只需要满足其中一部分就可能满足整个布尔表达式，所以我们将 DNF 拆分成独立的子句子 C
  * 且拆分：在且关系的子句中，满足所有的等于且未满足不等于即可，我们将 `=` 的数量记为 k
  * 将所有上述信息计入倒排索引中
  * 同时，将 k 为 0 的子句写入一个补全的 z 索引中，以满足未命中不等于的情况
5. 倒排索引
  * a,1：[{ BE1-C1: { p: '=', k: 3 }}、{ BE3-C1: { p: '=', k: 1}}、{ BE4-C1: { p: '=', k: 1}}]
  * a,2：[{ BE2-C1: { p: '=', k: 2}}]
  * b,2：[{ BE1-C1: { p: '=', k: 3 }}、{ BE3-C1: { p: '!=', k: 1}}、{ BE4-C1: { p: '!=', k: 0}}]
  * b,3：[{ BE2-C1: { p: '=', k: 2 }}、{ BE4-C1: { p: '!=', k: 1 }}]
  * c,1：[{ BE1-C1: { p: '=', k: 3 }}、{ BE2-C2: { p: '=', k: 1 }}、{ BE3-C2: { p: '=', k: 1 }]
  * c,2: [{ BE1-C2: { p: '=', k: 1 }}]
  * z: [{ BE5-C1: { p: '=', k: 0 }}]
6. 剪枝：
  * 对于只有两个属性的目标，最多只能满足两个等于条件
  * 以 `s1: a=1、b=3` 为例所以可以将 k > 2 的过滤掉
  * 再进行 a,1、b,3 的查找得出新的倒排索引
7. 索引命中：
  * a,1：[{ BE3-C1: { p: '=', k: 1 }}、{ BE4-C1: { p: '=', k: 1 }}]
  * b,3：[{ BE2-C1: { p: '=', k: 2 }}、{ BE4-C1: { p: '!=', k: 1 }}]
  * z: [{ BE5-C1: { p: '=', k: 0 }}]
8. 子句判断：以子句分组判断子句是否匹配
  * BE2-C1：
    * 命中：{ p: '=', k: 2 }
    * 判断：需满足 2 个等于，子句内仅有一项，不符合
  * BE3-C1：
    * 命中：{ p: '=', k: 1 }
    * 判断：需满足 1 个等于，子句内有一项，符合
  * BE4-C1：
    * 命中：{ p: '=', k: 1 }、{ p: '!=', k: 1 }
    * 判断：需满足 1 个等于，分组内有多于一项，但是命中了一项不等于，导致子句整体判断为假，不符合
  * BE5-C1：
    * 命中：{ p: '=', k: 0 }
    * 判断：需满足 0 个（未出现不等于，这也是 z 的作用）等于，分组内为一项，符合
9. 结果：
  * BE5 的 第一个子句 C1 匹配
  * true 或 ? 恒为 true
  * 最终匹配了布尔表达式 BE5