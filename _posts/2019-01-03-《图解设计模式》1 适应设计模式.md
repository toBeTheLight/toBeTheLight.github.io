---
layout: post
title:  "阅读：《图解设计模式》1 适应设计模式"
categories: 阅读笔记 设计模式
tags:  设计模式 迭代器模式 适配器模式
author: toBeTheLight
---

* content
{:toc}
首先介绍了两个较为容易理解的设计模式：Iterator 迭代器模式和 Adapter 适配器模式。




# Iterator 迭代器模式

## 定义

迭代器是专用于迭代的一个对象，可以让用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现，分离了遍历和实现。

## 角色

* 集合接口类：定义了集合类必须有创建迭代器的接口。
* 迭代器接口类：定义了迭代器对象具体接口，由实现角色实现其定义的接口。
* 集合实现类：实现具体迭代器，实现时会调用`具体的迭代器实现类`。
* 迭代器实现类：`迭代器接口类`的实现角色，实现`迭代器接口类`定义的所有接口，~~由于其需要对集合容器中的元素进行操作，所以`迭代器实现类`对`集合实现类`应该是知晓的，在后续的代码中我们可会看到~~。

## JavaScript 实现

在 JavaScript 中能规定接口的方式有很多种，如约定俗称（注释）、单元测试、TypeScript 等，我们使用基于 Class 弱约束进行代码示例。

```js
// * 集合接口类
class Aggregate {
  iterator () {
    throw new Error('需实现 Aggregate 类的 iterator 方法')
  }
}
// * 迭代器接口类
class Iterator {
  hasNext () {
    throw new Error('需实现 Iterator 类的 hasNext 方法')
  }
  next () {
    throw new Error('需实现 Iterator 类的 next 方法')
  }
}
// * 集合实现类
class LikeArray extends Aggregate {
  constructor(list) {
    super()
    this.list = list
  }
  getByIndex (index) {
    return this.list[index]
  }
  getLength () {
    return this.list.length
  }
  iterator () {
    return new ReverseIterator(this)
  }
}
// * 迭代器实现类
class ReverseIterator extends Iterator {
  constructor (array) {
    super()
    this.array = array
    this.index = this.array.getLength()
  }
  hasNext () {
    if (this.index >= 0) {
      return true
    } else {
      return false
    }
  }
  next () {
    const item = this.array.getByIndex(this.index)
    this.index -= 1
    return item
  }
}
// * 使用
const likeArray = new LikeArray([5,4,3,2,1])
const iterator = likeArray.iterator()
while(iterator.hasNext()) {
  console.log(iterator.next())
}
```

## 拓展

