---
layout: post
title:  "《领域驱动设计》"
categories: 阅读笔记
tags:  架构
author: toBeTheLight
---

* content
{:toc}








# 摘录

首先是阅读过程中的一些摘录。

> 尽管他们在技术使用方面也值得商榷，但真正挫败他们的是业务逻辑。

> 错误地将开发人员的角色独立出来，导致建模与实现脱节，因此设计无法反映不断深化的分析。

> 很多应用程序最主要的复杂性并不在技术上，而是来自领域本身、用户的活动或业务。

> 领域模型是对知识严格的组织且有选择的抽象，出于某种目的而概括地反映现实。

## 运用领域模型

先来提一个问题，什么是领域模型？

> 软件的核心是为其用户解决领域相关的问题的能力，其它特性都要**服务**于这个基本目的。

* 注：或许可以说模型是与技术无关的有关业务的描述？

### 消化知识

> 通过头脑风暴活动创建新的模型或者修改原有的模型对象，并消化理解这些模型对象中的知识。

> 模型包含各种类型的知识。

> 不再使用的或不重要的概念被从模型中移除。当一个不需要的概念与一个需要的概念有关联时，则把重要的概念提取到一个新模型中，不重要的概念可以丢弃。

> 知识消化由开发人员和领域专家组成的团队来共同完成。

> 高效的领域建模人员是知识的消化者，努力寻找对大量信息有意义的简单视图，只有找到一组适用于所有细节的抽象概念后，才算成功。

> 领域模型的不断精化迫使开发人员学习重要的业务原理，而不是机械的进行功能开发。

> 分析员和程序员将自己的知识输入到模型中，模型的组织更严密，抽象更简洁。领域专家也将他们的知识输入到模型中，模型反映了业务的深层次知识，而且真正的**业务原则**得以抽象。

> 项目知识零散地分散在很多人的文档中，我们并没意识到不知道的东西究竟有多少。同时，所有项目都会丢失知识。

> 模型获得的知识远远不只是“发现名词”。业务活动和规则如同所涉及的实体一样，都是领域的核心。

> 知识消化所产生的模型能够反映出对知识的深层理解。开发人员对模型实现进行重构，以反映出模型的变化，同时，新的知识就被整合到应用程序中。

> 当我们的建模不再局限于寻找**实体**和**值对象**时，我们才能充分吸取知识。

* 注：此章节埋了一个线，运用了整洁代码的方式，将一条过程式的包含业务知识的逻辑封装成了一个可视的策略调用，使业务规则直接可见。但这应该不是领域模型的应用方式吧，我猜？但显而易见的是，更明确的设计确实使得业务规则明确且显得重要，也可以更方便的与不太懂代码的人展示并对齐理解。

> 随着对领域和应用程序所需要的理解逐渐加深，一些开始不可能发现的巧妙抽象就会渐渐浮出水面，而它们恰恰切中问题要害。

> 有了更深刻的认识后，我们对航运业务的认识从“集装箱在各个地点之间的传输”转变为“运输责任在各个实体之间的传递”。

### 交流与语言的使用

> 要想创建一种灵活的、蕴含丰富知识的设计，需要一种通用的、共享的团队语言，以及对语言不断的试验。

> 日常讨论所使用的术语与代码中所使用的术语不一致。导致对领域的深刻表述常常稍纵即逝。同时翻译使得沟通不畅，并削弱了知识消化。项目需要一种公共语言，领域模型可以成为这种公共语言的核心，同时将团队沟通与软件实现紧密联系到一起。

> 通用语言的词汇包括类和主要操作的名称。

* 通用语言：Ubiquitous Language

> 模型可能缺乏开发人员在代码中所创建的更为微妙和灵活的特性，这要么是因为开发人员认为模型不必具备这些特性，要么是因为编码风格是过程式的，只能隐含的表达领域概念。

> 通用语言是那些以非代码形式呈现的设计的主要载体，这些包括把整个系统组织在一起的大尺度结构、定义了不同系统和模型之间关系的限界上下文，以及在模型和设计中使用的其他模式。

* 注：感觉很重要，但是不懂，后面再看。

## 模型驱动设计的构造块

### 分离领域

> 我们需要将领域对象与系统中的其他功能分离，这样就能够避免将领域概念和其他只与软件技术相关的概念搞混了。

> 分层的价值在于每一层都只代表程序中的某以特定方面。大多数的分层架构使用的都是这四个概念层的变体：用户界面层（表示层）、应用层、领域层（或模型层）、基础设施层。虽然项目间会有差异，但是将领域层分离出来才是实现模型驱动设计的关键。

> 负责处理基本业务规则的的是领域层，而不是应用层。

> 各层之间是松散连接的，层与层的依赖关系只能是单向的。上层可以直接使用或操作下层元素，通过调用下层元素的公共接口，保持对下层元素的引用。

> 最早将用户界面与应用层和领域层相连的模式是 MVC。

* 注：MVC、MVVM、MVX 三层模型中的桥梁部分往往包含了用户界面层的操作逻辑、应用层逻辑和领域层的操作逻辑。是否能通过某种模式再进行一次区分呢？感觉可能也许纯前端领域复杂度也很难到这个程度。

> 当使用框架时，项目团队应该明确其使用目的：建立一种可以表达领域模型的实现并且用它来解决重要问题。

### 软件中所表示的模型

* 模型：
  * Entity：具有连续性和标识的事物
  * Value Object：描述某种状态的属性
  * Service：动作和操作，稍稍违背了面向对象的建模传统

> 对象之间的关联使得建模与实现之间的交互更为复杂。

> 模型中每个可遍历的关联，软件中都要有相同属性的机制（注：即设计要反映模型将关系）。

> 设计无需如此直接。（注：在这句话之前，作者举了一个具体的实现方式。所以这句话的意思是，在进行设计时，设计好对应模型的方法即可，不必关注具体，能反映模型即可。）

#### Entity

> 很多对象不是通过他们的属性定义的，而是通过连续性和标识定义的。

> 有时，这样的对象必须与另一个具有不同属性的对象相匹配，有时一个对象必须与具有相同属性的另一个对象区分开。

> 主要由标识定义的对象被称为 Entity（注：即有一个在系统中不重复的标识方式，如 id、uid 等属性或由一些属性组合判断的方式，这个对象可能是跨系统的，可能在不同系统中属性是不同的，但由标识逻辑却可判断是同一个对象。

* 注：顾名思义，Entity，实体，对应一个由标识区分的具体事物。

> Entity 最基本的职责是确保连续性，保持简练是实现这一责任的关键。不要讲注意力集中在属性或行为上，应该摆脱这些细枝末节。
  * 抓住 Entity 对象定义的最基本特征，尤其是那些勇于识别、查找或匹配对象的特征。只添加那些对概念至关重要的行为和这些行为所必需的属性。
  * 将行为和属性转移到与核心 Entity 关联的其他对象中。
  * Entity 往往通过协调其关联对象的操作来完成自己的职责。

#### Value Object

> 很多对象没有概念上的标识，它们描述了一个事物的某种特征。

> 用于描述领域的某个方面而本身没有概念标识的对象称为 Value Object（值对象）。被实例化之后用来表示一些设计元素，对于这些设计元素，我们只关心它们是什么，而不关心它们是谁。

> Value Objct 可以是其他对象的集合。

> 当我们只关心一个模型元素的属性时，应把它归类为 Value Object。我们应该使这个模型元素能够表示出其属性的意义，并为它提供相关功能。Value Object 应该是不可变的。不要为它分配任何标识。