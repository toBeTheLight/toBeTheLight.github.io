webpackJsonp([0],{"3Ixl":function(n,e){n.exports='<h1 id="-">具体问题</h1>\n<h2 id="questionTemplate">模板</h2>\n\n<h4 id="-static-">引用static文件夹内文件问题</h4>\n<ol>\n<li>引入方式<ul>\n<li>html页面引用使用&#39;./static/&#39;方式引入<br><code>&lt;img src=&quot;./static/logo.png&quot;&gt;</code></li>\n<li>.vue文件内引用使用&#39;static/&#39;方式引入<br><code>&lt;img src=&quot;static/logo.png&quot;&gt;</code>\nwebpack会对src内路径做编译，所以引入路径不同。</li>\n</ul>\n</li>\n<li>文件数量<br>若static文件夹下文件数量过多，run build时可能会遇到<code>too many open files</code>错误<br>此时可注释掉<code>build/webpack.prod.conf.js</code>下   <pre><code> // copy custom static assets\n   new CopyWebpackPlugin([\n     {\n       from: path.resolve(__dirname, &#39;../static&#39;),\n       to: config.build.assetsSubDirectory,\n       ignore: [&#39;.*&#39;]\n     }\n   ])\n</code></pre> 插件，并在build执行结束后，将<code>static</code>下文件手动拷贝至<code>dist/static</code>下</li>\n</ol>\n<h2 id="questionNpmInstall">依赖安装</h2>\n\n<p>我们在<strong>Npm配置</strong>部分已经说明了更换源的方法。然而仍有两个依赖容易出现安装失败。\n分别是：</p>\n<ol>\n<li>phantomjs-2.1.1-windows.zip</li>\n<li>chromedriver</li>\n</ol>\n<p>可分别使用一下方法解决:  </p>\n<ol>\n<li>手动下载并复制到目标路径，使用下方命令行中提示地址或使用<a href="https://npm.taobao.org/dist/phantomjs/" target="phantomjs-download">国内镜像</a><pre><code>//这里的路径就是文件的下载路径\nDownloading https://github.com/Medium/phantomjs/releases/download/v2.1.1/phantomjs-2.1.1-windows.zip\n//下载好的文件放到上面这个指定的目录下面\nSaving to C:\\Users\\Administrator\\AppData\\Local\\Temp\\phantomjs\\phantomjs-2.1.1-windows.zip\n</code></pre></li>\n<li><code>npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver</code></li>\n</ol>\n<h2 id="questionAxios">axios</h2>\n\n<p>我们在<strong>AJAX</strong>部分介绍了axios做Promise兼容的方式。\n同时由于axios默认使用json格式数据，且请求头为<code>applistion/json</code>，若后端接口未做兼容，只能接受传统的表单序列化数据和<code>application/x-www-form-urlencoded</code>，则需要做额外请求头配置和数据处理。可导入使用node自带qs模块。</p>\n<pre><code>import qs from &#39;qs&#39;\n// 改变默认配置\naxios.defaults.headers = {\n  &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;\n}\n// 兼容form-data方式进行数据转换\naxios.defaults.transformRequest = [function (data) {\n  data = Qs.stringify(data)\n  return data\n}]\n</code></pre>'},NL57:function(n,e){n.exports='<h1 id="-">简介</h1>\n<p>此文档是基于<strong>模板部分</strong>所提供的模板的说明。</p>\n<p>目前前端的整个开发环境使用了：</p>\n<ol>\n<li>vueJS（前端js框架）</li>\n<li>Element（ui组件库）</li>\n<li>vue-cli（构建项目方式）</li>\n<li>node.js(运行环境)</li>\n<li>npm(包管理器) </li>\n<li>Webpack（打包和构建工具）</li>\n</ol>\n<p>此指南将会就此进行说明。</p>\n'},Ni3J:function(n,e){n.exports='<h1 id="vue-">Vue圈子</h1>\n<h2 id="vueOffical">官方库</h2>\n\n<p>vue目前的官方库，我们已经直接用到的有：</p>\n<ol>\n<li><a href="https://cn.vuejs.org/" target="vue-offical">vue</a> 主框架。</li>\n<li><a href="https://router.vuejs.org/zh-cn/" target="vue-router-offical">vue-router</a> 路由。</li>\n<li><a href="https://github.com/vuejs/vue-cli" target="vue-cli-offical">vue-cli</a> 项目起始脚手架，我们的模板就是用它搭的。</li>\n</ol>\n<p>我们间接用到的有：</p>\n<ul>\n<li>vue-loader 解析单文件组件的weboack loader。</li>\n</ul>\n<p>我们可能会用到的有：</p>\n<ol>\n<li><a href="https://vuex.vuejs.org/zh-cn/" target="vuex-offical">vuex</a> 数据状态管理。</li>\n<li>vue-i18n 国际化库。</li>\n</ol>\n<p>强烈推荐你用的：</p>\n<ul>\n<li><strong><a href="https://github.com/vuejs/vue-devtools" target="devtools-officel">vue-devtools</a></strong> 这是一款浏览器插件，可以帮助你实时查看页面组件与状态。可以选择<a href="https://segmentfault.com/a/1190000009682735" target="byself">手动安装</a>。</li>\n</ul>\n<p>还有这个：</p>\n<p><a>awesome-vue</a> 汇总了非官方生态，awesome。</p>\n<h2 id="vueVue">Vue</h2>\n\n<p>这里只对常用用法做简要的说明，进阶用法请查阅<a href="https://cn.vuejs.org/v2/api/#选项-其它" target="vue-more">文档</a>或查看demo。</p>\n<p>在.vue组件中我们使用这种方法定义一个组件</p>\n<pre><code>&lt;template&gt;\n// html\n&lt;/template&gt;\n\nexport default {\n  name: &quot;app&quot;,\n  data () {\n    return {\n      // 数据\n    }\n  },\n  props：{\n    // 属性，为接口型api\n  },\n  computed: {\n    // 计算属性\n  },\n  methods: {\n    // 方法\n  },\n  watch: {\n    // 观察者\n  },\n  components: {\n    // 当前组件所引用组件\n  }\n  ...,\n  // 这是一些组件生命周期钩子\n  created () {\n    // 组件创建钩子函数\n  },\n  mounted () {\n    // 组件挂载钩子函数\n  },\n  activated () {\n    // 组件激活钩子函数\n  }\n  destroyed () {\n    // 组件销毁钩子函数\n  },\n  ...\n}\n\n&lt;style&gt;\n// 样式\n&lt;/style&gt;\n</code></pre><p>注: 对象中的方法我们可以直接简写</p>\n<pre><code>{\n  fun: function () {}\n}\n// 等同\n{\n  fun () {}\n}\n</code></pre><p>可查看ES6部分</p>\n<h4 id="vueTrans">编译阶段</h4>\n\n<ol>\n<li>vue-loader会解析你的单文件组件。并将template、script、css关联起来。  </li>\n<li>同时在vue的解析阶段会对属性性质的值做动态响应的处理并将其添加到组件对象上，如data中的值，prop中的值，各个methods、computed，这也就是为什么使用this方法可以直接调用到这些属性、方法，我们输出this时也可以观察到。</li>\n</ol>\n<h4 id="data">data</h4>\n<p>组件上的直接属性值，内部及向下层组件使用。尽量提前声明。不要动态添加。<br>注意：</p>\n<ol>\n<li>对于对象类型的data值，如<code>obj: {key1: &#39;value1&#39;}</code>，如果我们做了<code>this.obj.key2 = &#39;value2&#39;</code>的直接添加属性的操作是无法响应的。可使用<code>Vue.set( target, key, value )</code>api，使vue对新属性进行动态响应处理。</li>\n<li>而数组使用<code>push()、pop()、shift()、unshift()、splice()、sort()、reverse()</code>方法时可正确响应，因为vue对几个方法做了处理。</li>\n</ol>\n<h4 id="props">props</h4>\n<p>props为接收父组件传入值的api，可传入所有数据类型。<br>同时，其为单向api，即只可接收不建议直接修改。我们可以使用其他方式做备份，比如使用computed做备份再修改。<br>修改props属性传入值时，应使用事件方式通知父组件修改。\n如下：</p>\n<pre><code>// 父组件\n&lt;template&gt;\n  // 将name传入子组件，子组件使用username接收\n  // 同时给子组件绑定update事件\n  &lt;son :username=&quot;name&quot; @update=&quot;updateName&quot;/&gt;\n&lt;/template&gt;\n// 导入子组件\nimport Son from &#39;./son.vue&#39;\nexport default {\n  data () {\n    return {\n      // 定义name的值\n      name: &#39;儿子&#39;\n    }\n  },\n  methods: {\n    // 定义事件回调，更新名字\n    updateName (newName) {\n      this.name = newName\n    }\n  },\n  components: {\n    // 注册子组件\n    Son\n  }\n}\n</code></pre><pre><code>子组件\nexport default () {\n  // 定义username ‘api’\n  props: [&#39;username&#39;],\n  mounted () {\n    // 触发事件，调用在父组件内的方法，并将值传递\n    this.$emit(&quot;update&quot;, &#39;改个名&#39;)\n  }\n}\n</code></pre><h4 id="computed">computed</h4>\n<p>此为计算属性，其值依赖其他属性的值(不只是data)生成。如：</p>\n<pre><code>data () {\n  return {\n    key1: &#39;value1&#39;,\n    key2: &#39;value2&#39;\n  }\n},\ncomputed: {\n  newValue () {\n    // 依赖于key1和key2的值\n    var value = this.key1 + this.key2\n    return value\n  }\n}\n// 这样我们就能使用this.newValue了,并且当key1或key2的值变化时就会跟随变化\n</code></pre><h4 id="methods">methods</h4>\n<p>在组件内定义方法</p>\n<pre><code>methods: {\n  fun (val) { \n    console.log(val)\n  },\n  fun2 (val) {\n    this.fun(val)\n  }\n}\n</code></pre><p>我们定义了两个函数，且可通过<code>this.fun()</code>,<code>this.fun2(123)</code>直接调用，且具体函数内this也为当前组件实例，可直接引用其他数据，如方法<code>fun2</code>。</p>\n<h4 id="watch">watch</h4>\n<p>此属性与<code>computed</code>属性类似，也是主动做动态响应的一个属性。</p>\n<pre><code>data () {\n  return {\n    key: &#39;value&#39;\n  }\n},\nwatch: {\n  // 监听data中key的值的变化，如果改变则做函数体内操作\n  key (newValue, oldValue) {\n    // 做操作，可拿到变化前后的值\n  },\n  &#39;$router&#39; () {\n    // 常用来检测路由的改变\n  }\n}\n</code></pre><p>与<code>computed</code>不同的是，<code>watch</code>注重过程，<code>computed</code>为了得到结果。</p>\n<h4 id="components">components</h4>\n<p>定义当前组件内使用的子组件\nvue对template进行编译的时候会识别标签，未识别的标签会在components内进行匹配。</p>\n<pre><code>&lt;template&gt;\n  &lt;my-component&gt;\n  &lt;/my-component&gt;\n  // 标签使用组建时也可以使用大驼峰命名法\n  &lt;MyComponent&gt;\n  &lt;/MyComponent&gt;\n&lt;/template&gt;\n// 组件名建议使用大驼峰命名法\nimport MyComponent from &#39;./MyComponent&#39;\ncomponents: {\n  MyComponent\n}\n</code></pre><h4 id="vueLife">生命周期钩子函数</h4>\n\n<p><a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="vue-offical-life">官网生命周期示意图</a>\n文档中有生命周期顺序的介绍</p>\n<pre><code>##### created\n</code></pre><p>created () {\n  // 此时实例已创建完毕，可访问this，修改或保存数据，\n  // 可在此做接口的访问去请求数据等\n}</p>\n<pre><code>##### mounted\n</code></pre><p>mounted () {\n  // 组件挂载钩子函数\n  // 当前组件已经被添加到文档上。可获取元素，做chart等需要依赖于dom对象的初始化工作。\n  // 注意：此钩子函数为当前组件的挂载状态，不保证子组件。\n  // 可使用this.$nextTick()\n  this.$nextTick(() =&gt; {\n    // 操作\n    // 此为箭头函数，见es6部分\n  })\n}</p>\n<pre><code>activated () {\n  // 组件激活钩子函数\n  // 一般配合router的keepalive使用\n  // 做数据的刷新\n}\ndestroyed () {\n  // 组件销毁钩子函数\n  // 取消window相关事件，setInterval或非组件的事件解绑(window.addEventListener)\n}\n</code></pre>'},ekGF:function(n,e){n.exports='<h1 id="-">模板</h1>\n<p>我们的模板是由 vue-cli webpack改写而来的可进行多页面开发的模板。<br>可去项目初始化部分下载。<br>项目开发使用库可查看<strong>依赖选型</strong>部分。<br>使用中遇到的问题可查看<strong>具体问题</strong>部分。</p>\n<h2 id="-">结构</h2>\n<pre><code>│  package-lock.json 项目描述锁定文件，可维持项目稳定\n│  package.json      项目描述文件\n│  README.md         项目说明文件\n│  \n├─build\n│      build.js              构建脚本\n│      check-versions.js     开发环境版本监测脚本\n│      utils.js              多页面配置及其他配置\n│      vue-loader.conf.js    vue-loader插件配置(解析.vue组件)\n│      webpack.base.conf.js  开发与生产环境构建通用配置\n│      webpack.dev.conf.js   开发环境构建配置\n│      webpack.prod.conf.js  生产环境构建配置\n│      \n├─config              构建配置目录\n│      dev.env.js     可配置开发与生产环境常量\n│      index.js\n│      prod.env.js\n│      \n├─dist       生产环境代码，未运行npm run build时不存在\n│              \n├─node_modules      项目依赖\n|                  \n├─src        项目源代码\n│                  \n└─static     静态文件目录\n</code></pre><h2 id="-">使用说明</h2>\n<p>在进行<code>npm install</code>之后。\n<code>npm install</code>部分遇到的安装失败问题可查看具体问题部分。</p>\n<h4 id="-">单页面项目</h4>\n<p>在<code>src/pages/index</code>下进行开发即可</p>\n<h4 id="-">多页面项目</h4>\n<ol>\n<li>复制<code>src/pages/index</code>并重命名为<code>src/pages/[name]</code></li>\n<li>将文件夹内<code>index.js</code>与<code>index.html</code>重命名为<code>[name].js</code>和<code>[name].html</code></li>\n<li>各页面名不可重复</li>\n</ol>\n<p>即如下结构，三者同名</p>\n<pre><code>├─index\n│  │  App.vue\n│  │  index.html\n│  │  index.js\n│  │  \n│  └─router\n│          index.js\n│          \n└─river             文件夹名\n    │  App.vue\n    │  river.html   html入口名\n    │  river.js     js入口名\n    │  \n    └─router\n            index.js\n</code></pre><h2 id="-">推荐结构</h2>\n<p>demo可<a href="javascript:alert(\'暂无\')">下载</a><br>我们以某一个单页为例，假如为manager单页，针对常用文件和配置可使用如下结构。</p>\n<pre><code>└─manager\n   │  App.vue            此单页根组件\n   │  manager.html         此单页html\n   │  manager.js           此单页入口文件\n   │ \n   ├─views               路由页面\n   │   ├─river                \n   │   │   │ river.vue   此路由组件\n   │   │   └─children    此路由下级路由组件\n   │   │       state.vue\n   │   │       control.vue\n   |   |\n   |   └─person\n   |         person.vue\n   |\n   ├─store               此单页数据状态管理(使用vuex时有)\n   |\n   |\n   ├─router\n   │  index.js           此单页路由配置\n   │\n   └─api                 此单页请求管理(多页面应用也可统一放在外层)\n      path.js            请求路径配置\n      http.js            ajax请求库配置\n      index.js           配置导出\n</code></pre><p>其他如项目公用组件、vue自定义指令、公用资源等放在src目录层即可，尽量且合理拆分。</p>\n<p>webpack配置可查看webpack部分。</p>\n'},jDjW:function(n,e){n.exports='<h1 id="-">其他依赖</h1>\n<p>补充</p>\n'},jk9C:function(n,e){n.exports='<h1 id="npm">npm</h1>\n<p>npm为依赖于Node的包管理工具</p>\n<h2 id="-">配置</h2>\n<p>在node部分我们已经安装好了Node，此时npm已随Node安装。  </p>\n<h4 id="-cache-">全局包路径与cache路径</h4>\n<p>在你安装node的文件夹(与node.exe)同级下新建<code>node_global</code>及<code>node_cache</code>文件夹。<br>命令行执行<br><code>npm config set prefix &quot;x:\\xxx\\nodejs\\node_global&quot;</code><br><code>npm config set cache &quot;x:\\xxx\\nodejs\\node_cache&quot;</code>  </p>\n<h4 id="npm-">npm源配置</h4>\n<p>npm下载包资源官方源在外网，下载时可能会遇到网络状况不佳等不可抗拒因素，我们可以设置使用国内镜像源。\n下面的地址为淘宝镜像，当然我们也可以在搭建私有npm源后设置私有npm源地址。</p>\n<ol>\n<li>永久设置的几种方式<ul>\n<li><code>npm config set registry https://registry.npm.taobao.org</code></li>\n<li>在node目录下找到<code>.npmrc</code>文件，添加<code>registry = https://registry.npm.taobao.org</code></li>\n</ul>\n</li>\n<li>临时使用<ul>\n<li><code>npm --registry https://registry.npm.taobao.org install [包名]</code>安装依赖时添加--registry字段</li>\n</ul>\n</li>\n<li>其他方式<ul>\n<li>安装cnpm，并以后使用cnpm代替npm命令</li>\n</ul>\n</li>\n</ol>\n<h2 id="-">常用命令</h2>\n<p>命令与详情可查看<a href="https://docs.npmjs.com/cli/access" target="npm-doc">官方文档</a></p>\n<h4 id="npm-install-">npm install(安装)</h4>\n<p>可简写为<code>npm i</code></p>\n<ol>\n<li><code>npm install [包名]</code> 在当前目录下安装依赖的最新版本。</li>\n<li><code>npm install [包名] -g</code>全局安装指定依赖，安装至上面配置的全局路径中，一般只有可命令行终端调用的依赖才全局安装。</li>\n<li><code>npm install [包名]@1.1.2</code> 安装1.1.2版本依赖。</li>\n<li><code>npm install [包名] --save</code>安装包并写入 package.json文件<code>dependencies</code>字段。</li>\n<li><code>npm install [包名] --dev</code>安装包并写入 package.json文件<code>devDependencies</code>字段。</li>\n<li><code>npm install</code>在当前目录下寻找package.json文件，并在当前目录安装<code>dependencies</code>(生产)与<code>devDependencies</code>(开发)字段中依赖配置的最新版本。</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>以上字段可结合使用。</li>\n<li>在<code>npm install</code>之后会生成<code>package-lock.json</code>文件，作用是锁定项目信息，保证各开发人员<code>npm install</code>依赖版本完全相同。</li>\n</ol>\n<h4 id="npm-uninstall-">npm uninstall(卸载)</h4>\n<p><code>npm uninstall [包名]</code> --save 删除指定模块并移除package.json中配置</p>\n<h4 id="npm-config-">npm config(配置相关)</h4>\n<ol>\n<li><code>npm config list</code>列出npm配置</li>\n<li><code>npm config set [字段] [值]</code> 设置某个配置项的值</li>\n<li><code>npm config delete [字段]</code> 删除配置</li>\n</ol>\n'},lBI2:function(n,e){n.exports='<h1 id="-vue-">其他vue常见问题</h1>\n<p><a href="https://juejin.im/post/59fa9257f265da43062a1b0e" target="vueqa-from">此文章原文</a></p>\n<div data-v-13f76525="" data-v-3f216172="" class="container entry-view">\n  <div data-v-13f76525="" data-v-3f216172="" class="post-content-container">\n    <div data-v-13f76525="" data-v-3f216172="" class="entry-content post-content juejin-image-viewer__container">\n      <hr>\n      <h2 class="heading" data-id="heading-2">Q:安装超时(\n        <code>install timeout</code>)</h2>\n      <p>方案有这么些:</p>\n      <ul>\n        <li>\n          <strong>\n            <code>cnpm</code> : 国内对npm的镜像版本</strong>\n        </li>\n      </ul>\n      <pre><code class="hljs javascript" lang="JavaScript"><span class="hljs-comment">/<em>\n  cnpm website: <a href="https://npm.taobao.org/">https://npm.taobao.org/</a>\n  </em>/</span>\n\n  npm install -g cnpm --registry=https:<span class="hljs-comment">//registry.npm.taobao.org</span>\n\n\n  <span class="hljs-comment">// cnpm 的大多命令跟 npm 的是一致的,比如安装,卸载这些</span></code></pre>\n      <ul>\n        <li>\n          <p>\n            <strong>\n              <code>yarn</code> 和\n              <code>npm</code> 改源大法</strong>\n          </p>\n          <ul>\n            <li>使用 nrm 模块 :\n              <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fnrm" target="_blank"\n                rel="nofollow noopener noreferrer">www.npmjs.com/package/nrm</a>\n            </li>\n            <li>npm config :\n              <code>npm config set registry <a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></code>\n            </li>\n            <li>yarn config :\n              <code>yarn config set registry <a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></code>\n            </li>\n          </ul>\n        </li>\n      </ul>\n      <hr>\n      <h2 class="heading" data-id="heading-3">Q:安装一些需要编译的包:提示没有安装\n        <code>python</code>、build失败等</h2>\n      <p>因为一些\n        <code>npm</code> 的包安装需要编译的环境,\n        <code>mac</code> 和\n        <code>linux</code> 都还好,大多都齐全\n        <br>window 用户依赖\n        <code>visual studio 的一些库</code>和\n        <code>python 2+</code>,</p>\n      <p>windows的小伙伴都装上: </p>\n      <ul>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ffelixrieseberg%2Fwindows-build-tools" target="_blank"\n            rel="nofollow noopener noreferrer">windows-build-tools</a>\n        </li>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.python.org%2Fdownloads%2F" target="_blank" rel="nofollow noopener noreferrer">python 2.x</a>\n        </li>\n      </ul>\n      <hr>\n      <h2 class="heading" data-id="heading-4">Q:\n        <code>can&#39;t not find &#39;xxModule&#39;</code> - 找不到某些依赖或者模块</h2>\n      <p>这种情况一般报错信息可以看到是哪个包抛出的信息.\n        <br>一般卸载这个模块,安装重新安装下即可.</p>\n      <hr>\n      <h2 class="heading" data-id="heading-5">Q:\n        <code>data functions should return an object</code>\n      </h2>\n      <p>这个问题是 Vue 实例内,单组件的\n        <code>data</code>必须返回一个对象;如下</p>\n      <pre><code class="hljs javascript" lang="JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">&#39;page-router-view&#39;</span>,\n        data () {\n        <span class="hljs-keyword">return</span> {\n          <span class="hljs-attr">tabs</span>: [\n            {\n              <span class="hljs-attr">title</span>: <span class="hljs-string">&#39;财务信息&#39;</span>,\n              <span class="hljs-attr">url</span>: <span class="hljs-string">&#39;/userinfo&#39;</span>\n            },\n            {\n              <span class="hljs-attr">title</span>: <span class="hljs-string">&#39;帐号信息&#39;</span>,\n              <span class="hljs-attr">url</span>: <span class="hljs-string">&#39;/userinfo/base&#39;</span>\n            }\n          ]\n        }\n      }\n  }</code></pre>\n      <p>\n        <strong>为什么要 return 一个数据对象呢?</strong>\n      </p>\n      <p>官方解释如下: data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！</p>\n      <p>简言之,组件复用下,不会造成数据同时指向一处,造出牵一发而动全身的破问题...</p>\n      <hr>\n      <h2 class="heading" data-id="heading-6">Q:我给组件内的原生控件添加事件,怎么不生效了!!!</h2>\n      <pre><code class="hljs html" lang="html">\n  <span class="hljs-comment">&lt;!--比如用了第三方框架,或者一些封装的内置组件; 然后想绑定事件--&gt;</span>\n\n  <span class="hljs-comment">&lt;!--// 错误例子1--&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入特定消费金额 &quot;</span> @<span class="hljs-attr">mouseover</span>=<span class="hljs-string">&quot;test()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>\n\n\n  <span class="hljs-comment">&lt;!--// 错误例子2--&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;item.menuUrl&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleName=&#39;&#39;&quot;</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#39;fzicon&#39;,item.menuIcon]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{item.menuName}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>\n\n\n  <span class="hljs-comment">&lt;!--上面的两个例子都没法触发事件!!!--&gt;</span>\n  <span class="hljs-comment">&lt;!--究其原因,少了一个修饰符 .native--&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;item.menuUrl&quot;</span> @<span class="hljs-attr">click.native</span>=<span class="hljs-string">&quot;toggleName=&#39;&#39;&quot;</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#39;fzicon&#39;,item.menuIcon]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{item.menuName}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>\n\n  <span class="hljs-comment">&lt;!--明明官方文档有的,一堆人不愿意去看,,Fuck--&gt;</span>\n  <span class="hljs-comment">&lt;!--<a href="https://cn.vuejs.org/v2/guide/components.html#给组件绑定原生事件--&amp;gt">https://cn.vuejs.org/v2/guide/components.html#给组件绑定原生事件--&amp;gt</a>;</span></code></pre>\n      <hr>\n      <hr>\n      <h2 class="heading" data-id="heading-7">Q:我用了\n        <code>axios</code> , 为什么 IE 浏览器不识别(IE9+)</h2>\n      <p>那是因为 IE 整个家族都不支持 promise, 解决方案:</p>\n      <pre><code class="hljs javascript" lang="JavaScript">\n  npm install es6-promise\n\n  <span class="hljs-comment">// 在 main.js 引入即可</span>\n  <span class="hljs-comment">// ES6的polyfill</span>\n  <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;es6-promise&quot;</span>).polyfill();</code></pre>\n      <hr>\n      <h2 class="heading" data-id="heading-8">Q:我在函数内用了\n        <code>this.xxx=</code>,为什么抛出\n        <code>Cannot set property &#39;xxx&#39; of undefined;</code>\n      </h2>\n      <p>这又是\n        <code>this</code>的套路了..\n        <code>this</code>是和当前运行的上下文绑定的...</p>\n      <p>一般你在\n        <code>axios</code>或者其他\n        <code>promise</code> , 或者\n        <code>setInterval</code> 这些默认都是指向最外层的全局钩子.</p>\n      <p>简单点说:&quot;最外层的上下文就是\n        <code>window</code>,vue内则是 Vue 对象而不是实例!&quot;;</p>\n      <p>解决方案:</p>\n      <ul>\n        <li>暂存法: 函数内先缓存\n          <code>this</code> , let that = this;(let是 es6, es5用 var)</li>\n        <li>箭头函数: 会强行关联当前运行区域为 this 的上下文;</li>\n      </ul>\n      <p>\n        <code>this</code>的知识, 读&quot;&lt;&lt;你不知道的 JS 系列&gt;&gt;&quot;最为合适了,里面讲的很清楚</p>\n      <hr>\n      <h2 class="heading" data-id="heading-9">Q:我看一些Vue教程有这么些写法,是什么意思\n        <code>@click.prevent</code>,\n        <code>v-demo.a.b</code>;</h2>\n      <p>就拿这两个例子来说吧.</p>\n      <ul>\n        <li>\n          <code>@click.prevent</code> : 事件+修饰符 , 作用就是点击但又阻止默认行为</li>\n        <li>\n          <code>v-demo.a.b</code>: 自定义指令+修饰符. 具体看你什么指令了,修饰符的作用大多是给事件增加一些确切的拓展功能</li>\n      </ul>\n      <p>比如阻止事件冒泡,阻止默认行为,访问到原生控件,结合键盘快捷键等等</p>\n      <p>传送门:\n        <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fevents.html%23%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"\n          target="_blank" rel="nofollow noopener noreferrer">事件修饰符</a>;</p>\n      <p>可以自定义修饰符么?也是可以的..</p>\n      <p>可以通过全局\n        <code>config.keyCodes</code> 对象自定义键值修饰符别名：</p>\n      <hr>\n      <h2 class="heading" data-id="heading-10">Q:为什么我的引入的小图片渲染出来却是\n        <code>data:image/png;base64xxxxxxxx</code>\n      </h2>\n      <p>这个是 webpack 里面的对应插件处理的.</p>\n      <p>对于小于多少 K 以下的图片(规定的格式)直接转为 base64格式渲染;</p>\n      <p>具体配置在\n        <code>webpack.base.conf.js</code>里面的 rules里面的\n        <code>url-loader</code>\n      </p>\n      <p>这样做的好处:在网速不好的时候先于内容加载和减少http的请求次数来减少网站服务器的负担。</p>\n      <hr>\n      <h2 class="heading" data-id="heading-11">Q:\n        <code>Component template shold contain exactly one root element.If you are useing  v-if on multiple elements , xxxxx</code>\n      </h2>\n      <p>大体就是说,单组件渲染 DOM 区域必须要有一个根元素,不能出现同级元素.\n        <br>可以用\n        <code>v-if</code>和\n        <code>v-else-if</code>指令来控制其他元素达到并存的状态</p>\n      <p>换个直白的解释,就是有一个唯一的父类,包裹者;</p>\n      <p>\n        <strong>比如一个 div(父包含块) 内部多少个同级或者嵌套都行,但是最外层元素不能出现同级元素!!!!\n        </strong>\n      </p>\n      <hr>\n      <h2 class="heading" data-id="heading-12">Q:跨域问题怎么破!比如\n        <code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code>\n      </h2>\n      <p>这种问题老生常谈了,我就不细说了..大体说一下;</p>\n      <p>1:\n        <code>CORS</code> , 前后端都要对应去配置,IE10+\n        <br>2:\n        <code>nginx</code> 反向代理,一劳永逸 &lt;-- 线上环境可以用这个</p>\n      <p>线下开发模式,比如你用了\n        <code>vue-cli</code>, 里面的 webpack 有引入了\n        <code>proxyTable</code>这么个玩意,\n        <br>也可以做接口反向代理</p>\n      <pre><code class="hljs javascript" lang="JavaScript"><span class="hljs-comment">// 在 config 目录下的index.js</span>\n\n  proxyTable: {\n    <span class="hljs-string">&quot;/bp-api&quot;</span>: {\n      <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;<a href="http://new.d.st.cn">http://new.d.st.cn</a>&quot;</span>,\n      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,\n      <span class="hljs-comment">// pathRewrite: {</span>\n      <span class="hljs-comment">//   &quot;^/bp-api&quot;: &quot;/&quot;</span>\n      <span class="hljs-comment">// }</span>\n    }\n  }\n\n  <span class="hljs-comment">// target : 就是 api 的代理的实际路径</span>\n  <span class="hljs-comment">// changeOrigin: 就是是变源,必须是...</span>\n  <span class="hljs-comment">// pathRewrite : 就是路径重定向,一看就知道</span></code></pre>\n      <p>当然还有依旧坚挺的\n        <code>jsonp</code>大法!不过局限性比较多,比较适合一些\n        <strong>特殊</strong>的信息获取!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-13">Q:我需要遍历的数组值更新了,值也赋值了,为什么视图不更新!!!</h2>\n      <p>那是因为有局限性啊,官方文档也说的很清楚,只有一些魔改的之后的方法提供跟原生一样的使用姿势(却又可以触发视图更新);</p>\n      <p>一般我们更常用(除了魔改方法)的手段是使用:\n        <code>this.$set(obj,item,value)</code>;</p>\n      <p>传送门:\n        <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Flist.html%23%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B"\n          target="_blank" rel="nofollow noopener noreferrer">数组更新检测(触发视图更新)</a>\n      </p>\n      <hr>\n      <h2 class="heading" data-id="heading-14">Q:为什么我的组件间的样式不能继承或者覆写啊!!!</h2>\n      <p>单组件开发模式下,请确认是否开启了\n        <code>CSS</code>模块化功能!!</p>\n      <p>也就是\n        <code>scoped</code>(vue-cli 里面配置了,只要加入这个属性就自动启用)</p>\n      <pre><code class="hljs html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>\n      <p>为什么不能继承或者覆写呢,那时因为每个类或者 id 乃至标签都会给自动在css后面添加hash!</p>\n      <p>比如</p>\n      <pre><code class="hljs css" lang="css">// 写的时候是这个\n  .trangle{}\n\n  // 编译过后,加上了 hash\n  .trangle[data-v-1ec35ffc]{}</code></pre>\n      <p>这些都是在 css-loader 里面配置!!!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-15">Q:路由模式改为\n        <code>history</code>后,除了首次启动首页没报错,刷新访问路由都报错!</h2>\n      <p>必须给对应的服务端配置查询的主页面..也可以认为是主路由入口的引导</p>\n      <p>官方文档也有,为毛总有人不喜欢去看文档,总喜欢做伸手党....FUCK</p>\n      <p>\n        <strong>传送门</strong> :\n        <a href="https://link.juejin.im?target=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fessentials%2Fhistory-mode.html"\n          target="_blank" rel="nofollow noopener noreferrer">Vue-Router history Mode</a>\n      </p>\n      <hr>\n      <h2 class="heading" data-id="heading-16">Q:我想拦截页面,或者在页面进来之前做一些事情,可以么?</h2>\n      <p>Of course !!</p>\n      <p>各种路由器的钩子!! 传送门:\n        <a href="https://link.juejin.im?target=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fadvanced%2Fnavigation-guards.html"\n          target="_blank" rel="nofollow noopener noreferrer">\n          <strong>导航守卫</strong>\n        </a>;</p>\n      <p>当然,记忆滚动的位置也可以做到,详情翻翻里面的文档</p>\n      <hr>\n      <h2 class="heading" data-id="heading-17">Q:\n        <code>TypeError: xxx is not a function</code>\n      </h2>\n      <p>这种问题明显就是写法有问题...能不能动点脑子!!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-18">Q:\n        <code>Uncaught ReferenceError: xxx is not define</code>\n      </h2>\n      <ul>\n        <li>实例内的\n          <code>data</code> 对应的变量没有声明</li>\n        <li>你导入模块报这个错误,那绝逼是导出没写好</li>\n      </ul>\n      <hr>\n      <h2 class="heading" data-id="heading-19">Q:\n        <code>Error in render function:&quot;Type Error: Cannot read property &#39;xxx&#39; of undefined&quot;</code>\n      </h2>\n      <p>这种问题大多都是初始化的姿势不对;</p>\n      <p>比如引入\n        <code>echart</code>这些...仔细去了解下生命周期,再来具体初始化;</p>\n      <p>vue 组件有时候也会(嵌套组件或者\n        <code>props</code>传递初始化)..也是基本这个问题</p>\n      <hr>\n      <h2 class="heading" data-id="heading-20">Q:\n        <code>Unexpected token: operator xxxxx</code>\n      </h2>\n      <p>大佬,这个一看就是语法错误啊.\n        <br>基本都是符号问题.\n        <br>一般报错会给出哪一行或者哪个组件</p>\n      <hr>\n      <h2 class="heading" data-id="heading-21">Q:\n        <code>npm run build</code>之后不能直接访问</h2>\n      <p>大佬!你最起码得在本地搭个服务器才能访问好么!!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-22">Q:CSS\n        <code>background</code>引入图片打包后,访问路径错误</h2>\n      <p>因为打包后图片是在根目录下,你用相对路径肯定报错啊....\n        <br>你可以魔改 webpack 的配置文件里面的\n        <code>static</code>为\n        <code>./static</code>...但是不建议</p>\n      <p>你若是把图片什么丢到\n        <code>assets</code>目录下,然后相对路径,打包后是正常的</p>\n      <hr>\n      <h2 class="heading" data-id="heading-23">Q:安装模块时命令窗口输出\n        <code>unsupported platform xxx</code>\n      </h2>\n      <p>一般两种情况,\n        <code>node</code>版本不兼容,系统不兼容;</p>\n      <p>解决方案: 要么不装,要么满足安装要求;</p>\n      <hr>\n      <h2 class="heading" data-id="heading-24">Q:\n        <code>Unexpected tab charater</code>这些</h2>\n      <p>一般是你用脚手架初始化的时候开了 eslint ;</p>\n      <p>要么遵循规则,要么改变规则;</p>\n      <p>要么直接把 webpack 里面的 eslint 检测给关闭了</p>\n      <hr>\n      <h2 class="heading" data-id="heading-25">Q:\n        <code>Failed to mount component: template or render function not defined</code>\n      </h2>\n      <p>组件挂载失败,问题只有这么几个</p>\n      <p>组件没有正确引入; 挂载点顺序错了了;</p>\n      <p>自行动手排查</p>\n      <hr>\n      <h2 class="heading" data-id="heading-26">Q:\n        <code>Unknown custom element: &lt;xxx&gt; - did you register the component correctly?</code>\n      </h2>\n      <p>组件没有正确引入或者正确使用,依次确认</p>\n      <ol>\n        <li>导入对应的组件</li>\n        <li>在 components 内声明</li>\n        <li>在 dom 区域声明标签</li>\n      </ol>\n      <hr>\n      <h2 class="heading" data-id="heading-27">Q:\n        <code>axios</code>的\n        <code>post</code> 请求后台接受不到!</h2>\n      <p>\n        <code>axios</code>默认是 json 格式提交,确认后台是否做了对应的支持;</p>\n      <p>若是只能接受传统的表单序列化,就需要自己写一个转义的方法...</p>\n      <p>当然还有一个更加省事的方案,装一个小模块\n        <code>qs</code>\n      </p>\n      <pre><code class="hljs javascript" lang="JavaScript">\n  npm install qs -S\n\n\n  <span class="hljs-comment">// 然后在对应的地方转就行了..单一请求也行,拦截器也行...我是写在拦截器的.</span>\n  <span class="hljs-comment">// 具体可以看看我 axios 封装那篇文章</span>\n\n  <span class="hljs-comment">//POST传参序列化(添加请求拦截器)</span>\n  Axios.interceptors.request.use(\n    <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> {\n      <span class="hljs-comment">// 在发送请求之前做某件事</span>\n      <span class="hljs-keyword">if</span> (\n        config.method === <span class="hljs-string">&quot;post&quot;</span>\n      ) {\n        <span class="hljs-comment">// 序列化</span>\n        config.data = qs.stringify(config.data); <span class="hljs-comment">// <strong>*</strong> 这里转义</span>\n      }\n\n      <span class="hljs-comment">// 若是有做鉴权token , 就给头部带上token</span>\n      <span class="hljs-keyword">if</span> (localStorage.token) {\n        config.headers.Authorization = localStorage.token;\n      }\n      <span class="hljs-keyword">return</span> config;\n    },\n    error =&gt; {\n      Message({\n        <span class="hljs-comment">//  饿了么的消息弹窗组件,类似toast</span>\n        showClose: <span class="hljs-literal">true</span>,\n        <span class="hljs-attr">message</span>: error,\n        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;error.data.error.message&quot;</span>\n      });\n      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error.data.error.message);\n    }\n  );</code></pre>\n      <hr>\n      <h2 class="heading" data-id="heading-28">Q:\n        <code>Invalid prop: type check failed for prop &quot;xxx&quot;. Expected Boolean, got String.</code>\n      </h2>\n      <p>这种问题一般就是组件内的\n        <code>props</code> 类型已经设置了接受的范围类型,\n        <br>而你传递的值却又不是它需要的类型,写代码严谨些 OK?</p>\n      <hr>\n      <h2 class="heading" data-id="heading-29">Q: 过滤器可以用于DOM区域结合指令么?</h2>\n      <pre><code class="hljs html" lang="html">// 不行,看下面的错误例子\n  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in range | sortByDesc | spliceText&quot;</span>&gt;</span>{{item}}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n\n  // <code>vue2+</code>的指令只能用语 mustache<code>{{}}</code> , 正确姿势如下:\n\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ message | capitalize }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>\n      <hr>\n      <h2 class="heading" data-id="heading-30">Q:\n        <code>[...Array]</code>,\n        <code>...mapState</code>,\n        <code>[SOME_MUTATION] (state) {}</code>,\n        <code>increment ({ commit }) {}</code>这种写法是什么鬼!</h2>\n      <p>出门左拐,ES6+(ES2015)的基础去过一遍..</p>\n      <p>上面依次:数组解构,对象解构,对象风格函数,对象解构赋值传递</p>\n      <hr>\n      <h2 class="heading" data-id="heading-31">Q: 我的 Vue 网站为什么 UC 访问一片空白亦或者\n        <code>flex</code>布局错乱!!</h2>\n      <p>来来来,墙角走起....\n        <strong>UC 号称移动界的 IE 这称号不是白叫的</strong>\n      </p>\n      <ul>\n        <li>\n          <code>flexbox</code> 布局错乱,一般是你没有把兼容方案写上..就是带各种前缀,复合属性拆分\n          <ul>\n            <li>看看我这篇文章:\n              <a href="https://link.juejin.im?target=http%3A%2F%2Fblog.csdn.net%2Fcrper%2Farticle%2Fdetails%2F51902681"\n                target="_blank" rel="nofollow noopener noreferrer">移动端爬坑记 --- （1）布局与样式上的奇葩偶遇</a>, 最好就用插件来代替人力吧,,引入\n              <code>autoprefixer</code>, 写上兼容范围就好了.</li>\n          </ul>\n        </li>\n        <li>\n          <code>UC访问空白</code>, 有一种情况绝对会造成,那就是 ES6的代码降级不够彻底. 其他情况可能就是路由配置问题(自己去排除)\n          <ul>\n            <li>现在的开发都推荐按需引入,靠\n              <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel-preset-env" target="_blank"\n                rel="nofollow noopener noreferrer">\n                <code>babel-preset-env</code>\n              </a> 来控制,以达到打包体积减小.</li>\n            <li>但是这样做的后果,有些内核比较老的...嘿嘿..拜拜..</li>\n            <li>所以最好把代码完全 ES5话!!记住有些特性不能乱使用,没有对应的\n              <code>polyfill</code>,比如 ES6 的\n              <code>proxy</code>\n            </li>\n          </ul>\n        </li>\n      </ul>\n      <hr>\n      <h2 class="heading" data-id="heading-32">Q:\n        <code>this.$set | this.$xxx</code> 这个\n        <code>$</code> 是个什么意思?是\n        <code>jQuery</code>的么,会冲突么?</h2>\n      <p>且看我细细道来.</p>\n      <p>Vue 的\n        <code>$</code>和 jQuery 的\n        <code>$</code>并没有半毛钱的关系,就跟\n        <code>javascript</code>和\n        <code>java</code>一样.</p>\n      <p>Vue 的\n        <code>$</code>是封装了一些 vue 的内建函数,然后导出以\n        <code>$</code>开头...这显然并不是\n        <code>jQuery</code>的专利;</p>\n      <p>jQuery 的\n        <code>$</code>是选择器!!取得 DOM区域...两者的作用完全不一致!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-33">Q:Module not found: Error : Can&#39;t resolve\n        <code>xxx-loader</code> in xxxx</h2>\n      <p>这里问题一般就是webpack的配置文件你改动了或对应的 loader 没有装上</p>\n      <hr>\n      <h2 class="heading" data-id="heading-34">Q: 父组件可以直接调用子组件的方法么!</h2>\n      <p>可以,通过\n        <code>$refs</code>或者\n        <code>$chilren</code>来拿到对应的实例,从而操作</p>\n      <hr>\n      <h2 class="heading" data-id="heading-35">Q:\n        <code>Error in event handler for &quot;click&quot;:&quot;xxx&quot;</code>\n      </h2>\n      <p>这个问题大多都是你写的代码有问题.你的事件触发了.\n        <br>但是组件内部缺少对应的实现或者变量,所以抛出事件错误.</p>\n      <p>解决方案:看着报错慢慢排查</p>\n      <hr>\n      <h2 class="heading" data-id="heading-36">Q: 组件的通讯有哪几种啊!!!</h2>\n      <p>基本最常用的是这三种;</p>\n      <ol>\n        <li>父传子:\n          <code>props</code>\n        </li>\n        <li>子传父:\n          <code>emit</code>\n        </li>\n        <li>兄弟通讯:\n          <ul>\n            <li>\n              <code>event bus</code>: 就是找一个中间组件来作为信息传递中介</li>\n            <li>\n              <code>vuex</code>: 信息树</li>\n          </ul>\n        </li>\n      </ol>\n      <p>传送门:</p>\n      <ul>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html" target="_blank"\n            rel="nofollow noopener noreferrer">基本通讯</a>\n        </li>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh-cn%2Fintro.html" target="_blank" rel="nofollow noopener noreferrer">Vuex</a>\n        </li>\n      </ul>\n      <hr>\n      <h2 class="heading" data-id="heading-37">Q:既然\n        <code>localStorage</code>和\n        <code>sessionStorage</code>能做到数据维护,为什么还要引入\n        <code>vuex</code>!</h2>\n      <p>这个问题问得好,\n        <code>Vuex</code>的目的用来维护同级组件间的数据通讯,拥有一个共同的状态树;</p>\n      <p>仅仅活在\n        <code>SPA</code>的里面的\n        <strong>伪多页(路由)</strong>内, 这种东东明明然\n        <code>localStorage</code>和\n        <code>sessionStorage</code>\n        <br>也可以做到,还能做到跨页面数据维护..还不会被浏览器刷新干掉...</p>\n      <p>为什么还要引入\n        <code>vuex</code>, 我个人觉得原因只有这么一个,&quot;可维护性&quot;和&quot;易用性&quot;及</p>\n      <p>怎么理解呢?</p>\n      <ul>\n        <li>可维护性: 因为是单向数据流,所有状态是有迹可循的...数据的传递也可以及时分发响应</li>\n        <li>易用性: 它使得我们组件间的通讯变得更强大,而不用借助中间件这类来实现不同组件间的通讯</li>\n      </ul>\n      <p>而且代码量不多,若是你要用\n        <code>ls</code>或者\n        <code>ss</code>,你必须手动去跟踪维护你的状态表...\n        <br>虽说可行,但是代码量会多很多,而且可读性很差...</p>\n      <p>是不是每个项目都需要用到\n        <code>vuex</code>?\n        <br>答案是否定的,小型项目上这个反而是累赘..这东西一般是用在中型项目+的,\n        <br>因为里面涉及需要维护的数据比较多,同级组件间的通讯比较频繁</p>\n      <p>若是用到\n        <code>vuex</code>的项目记得结合\n        <code>ss</code>或者\n        <code>ls</code>来达到某些状态持久化!!!为什么看下面!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-38">Q:vuex的用户信息为什么还要存一遍在浏览器里(sessionStorage or localStorage)</h2>\n      <p>因为\n        <code>vuex</code>的 store 干不过刷新啊.\n        <br>保存在浏览器的缓存内,若用户刷新的话,值再取一遍呗;</p>\n      <hr>\n      <h2 class="heading" data-id="heading-39">Q:&quot;有 Vue + Vue Router + Vuex&quot;或什么&quot;express + vue + mongodb&quot;的项目学习么</h2>\n      <p>Github 一搜一大堆,提这些问题的人动动脑子!.传送门:\n        <a href="https://link.juejin.im?target=http%3A%2F%2Fgithub.com%2F" target="_blank" rel="nofollow noopener noreferrer">\n          <strong>Github</strong>\n        </a>\n      </p>\n      <hr>\n      <h2 class="heading" data-id="heading-40">Q:线上若是 nginx,如何部署?以及反向代理这些!!</h2>\n      <p>传送门:\n        <a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F58bfc412da2f60124db5999a" target="_blank"\n          rel="nofollow noopener noreferrer">一篇不大靠谱的nginx 1.11.10配置文件</a>\n      </p>\n      <hr>\n      <h2 class="heading" data-id="heading-41">Q:&quot;我会 Vue 我还需要学习 jQuery 或者原生 JS 么&quot;</h2>\n      <p>\n        <code>jQuery</code>还有很多公司在用,源码可以学习的地方很多;</p>\n      <p>原生 js 是根本,不管是哪个前端框架,最终都是 js 实现的;\n        <br>只有基础扎实,才能学的比较深...</p>\n      <p>框架只是加快开发,提高效率,但不是你在这一行长期立足的根本;</p>\n      <p>前端的人不仅需要宽度,也要深度...这样才能走的更远....</p>\n      <hr>\n      <h2 class="heading" data-id="heading-42">Q: npm run dev 报端口错误!\n        <code>Error: listen EADDRINUSE :::8080</code>\n      </h2>\n      <ul>\n        <li>自己用 webpack搭脚手架的都不用我说了;</li>\n        <li>Vue-cli 里面的 webpack 配置: config/index.js</li>\n      </ul>\n      <pre><code class="hljs javascript" lang="JavaScript">  dev: {\n      <span class="hljs-attr">env</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./dev.env&quot;</span>),\n      <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>, <span class="hljs-comment">//  这里这里,若是这个端口已经给系统的其他程序占用了.改我改我!!!!!!</span>\n      autoOpenBrowser: <span class="hljs-literal">true</span>,\n      <span class="hljs-attr">assetsSubDirectory</span>: <span class="hljs-string">&quot;static&quot;</span>,\n      <span class="hljs-attr">assetsPublicPath</span>: <span class="hljs-string">&quot;/&quot;</span>,\n      <span class="hljs-attr">proxyTable</span>: {\n        <span class="hljs-string">&quot;/bp-api&quot;</span>: {\n          <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;<a href="http://new.d.st.cn">http://new.d.st.cn</a>&quot;</span>,\n          <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,\n          <span class="hljs-comment">// pathRewrite: {</span>\n          <span class="hljs-comment">//   &quot;^/bp-api&quot;: &quot;/&quot;</span>\n          <span class="hljs-comment">// }</span>\n        }\n      },</code></pre>\n      <hr>\n      <h2 class="heading" data-id="heading-43">Q: 什么时候用\n        <code>v-if</code>,什么用\n        <code>v-show</code>!</h2>\n      <p>我们先来说说两者的核心差异;</p>\n      <ul>\n        <li>\n          <code>v-if</code> : DOM 区域没有生成,没有插入文档..等条件成立的时候才动态插入到页面!\n          <ul>\n            <li>有些需要遍历的数组对象或者值,最好用这货控制,等到拿到值才处理遍历,不然一些操作过快的情况会报错,比如数据还没请求到!</li>\n          </ul>\n        </li>\n        <li>\n          <code>v-show</code>: DOM 区域在组件渲染的时候同时渲染了,只是单纯用 css 隐藏了\n          <ul>\n            <li>对于下拉菜单,折叠菜单这些数据基本不怎么变动.用这个最合适了..而且可以改善用户体验,因为它不会导致页面的\n              <strong>重绘</strong>,DOM 操作会! </li>\n          </ul>\n        </li>\n      </ul>\n      <p>简言之: DOM结构不怎么变化的用\n        <code>v-show</code>, 数据需要改动很大或者布局改动的用\n        <code>v-if</code>\n      </p>\n      <hr>\n      <h2 class="heading" data-id="heading-44">Q:\n        <code>&lt;template&gt;</code>是什么,html5的标签么?</h2>\n      <p>你猜对了..html5的标签还真有这么一个.传送门\n        <a href="https://link.juejin.im?target=https%3A%2F%2Fcaniuse.com%2F%23search%3Dtemplate" target="_blank"\n          rel="nofollow noopener noreferrer">Can I Use:template</a>\n      </p>\n      <p>不过 Vue 的 template 有点不一样,不是去给浏览器解析的....\n        <br>你可以理解为一个临时标签,用来方便你写循环,判断的....\n        <br>因为最终 template 不会解析到浏览器的页面,他只是在 Vue 解析的过程充当一个包裹层!\n        <br>最终我们看到的是内部处理后的组合的 DOM 结构!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-45">Q:\n        <code>the &quot;scope&quot; attribute for scoped slots …. replaced by &quot;slot-scope&quot; since 2.5</code>\n      </h2>\n      <p>这个问题只出现老项目升级到 vue2.5+的时候, 提示就是 scope 现在要用 slot-scope 来代替,\n        <br>但是 scope 暂时可以用,以后会移除</p>\n      <hr>\n      <h2 class="heading" data-id="heading-46">Q:\n        <code>Uncaught ReferenceError : Vue is not defined!</code>\n      </h2>\n      <p>依次排除:</p>\n      <ul>\n        <li>Vue是否正确引入!</li>\n        <li>Vue是否正确实例化!</li>\n        <li>Vue 用的姿势是否正确(比如你直接一个 Vue 的变量!!!刚好又没定义,,具体问题具体分析吧)</li>\n      </ul>\n      <hr>\n      <h2 class="heading" data-id="heading-47">Q:\n        <code>ERROR in static/js/xxxxxxx.js from UglifyJs</code>\n      </h2>\n      <p>我知道其中一种情况会报这种情况,就是你引入的 js,是直接引入压缩版本后的 js(\n        <code>xxx.min.js</code>);\n        <br>然后 webpack 内又启用了 UglifyJs(压缩 JS的), 二重压缩大多都会报错!!</p>\n      <p>解决方案:引入标准未压缩的 JS</p>\n      <hr>\n      <h2 class="heading" data-id="heading-48">Q:\n        <code>props</code>不使用\n        <code>:(v-bind)</code>可以传递值么!</h2>\n      <p>可以,只是默认传递的类型会被解析成字符串!\n        <br>若是要传递其他类型,该绑定还是绑定!!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-49">Q:\n        <code>Uncaught TypeError : Cannot set property xxx which has only a getter</code>\n      </h2>\n      <p>这个问题就是你要操作的属性只允许\n        <code>getter</code>,不允许\n        <code>setter</code>;</p>\n      <p>解决方案? 用了别人的东西就要遵循别人的套路来,不然就只能自己动手丰衣足食了!!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-50">Q: 单组件中里面的\n        <code>import xxx from &#39;@/components/layout/xxx&#39;</code>中的\n        <code>@</code>是什么鬼!</h2>\n      <p>这是 webpack 方面的知识,看到了也说下吧...</p>\n      <p>webpack可以配置\n        <code>alias</code>(也就是路径别名),玩过 linux 或者 mac 都知道</p>\n      <p>依旧如上,会自己搭脚手架的不用我说了...看看 vue-cli 里面的;</p>\n      <p>文件名: build -&gt; webpack.base.conf.js</p>\n      <pre><code class="hljs javascript" lang="JavaScript">\n   resolve: {\n      <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.vue&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>], <span class="hljs-comment">// 可以导入的时候忽略的拓展名范围</span>\n      alias: {\n        <span class="hljs-attr">vue$</span>: <span class="hljs-string">&quot;vue/dist/vue.esm.js&quot;</span>,<br>        <span class="hljs-string">&quot;@&quot;</span>: resolve(<span class="hljs-string">&quot;src&quot;</span>),  <span class="hljs-comment">// 这里就是别名了,比如@就代表直接从/src 下开始找起!!!</span>\n        <span class="hljs-string">&quot;~&quot;</span>: resolve(<span class="hljs-string">&quot;src/components&quot;</span>)\n      }\n    },</code></pre>\n      <hr>\n      <h2 class="heading" data-id="heading-51">Q:\n        <code>SCSS(SASS)</code> 还是\n        <code>less</code>,\n        <code>stylus</code> 好!!</h2>\n      <p>三者都是预处理器;</p>\n      <p>scss 出现最久,能做的功能比较多,但是若是普通的嵌套写法,继承,mixin 啊.</p>\n      <p>这三个都差不多..会其中一个其他两个的粗浅用法基本也会了.不过!!!!</p>\n      <p>写法有些差异:</p>\n      <ul>\n        <li>scss: 写法上是像 css 靠齐 </li>\n        <li>sass : 其实也就是 scss , 只是写法不一样...靠的是缩进</li>\n        <li>less : 跟 css 基本靠齐</li>\n        <li>stylus : 一样,靠缩进..跟\n          <code>pug(Jade)</code>一样</li>\n      </ul>\n      <p>使用环境的差异:</p>\n      <ul>\n        <li>scss 可以借助 ruby 或者 node-sass 编译</li>\n        <li>less 可以用 less.js 或者对应的 loader 解析</li>\n        <li>stylus 只能借助 loader 解析,它的出现就是基于 node 的</li>\n      </ul>\n      <p>也有一个后起之秀,主打解耦,插件化的!!! 那就是\n        <code>PostCSS</code>,这个是后处理器!!!\n        <br>有兴趣的可以自行去了解,上面的写法都能借助插件实现!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-52">Q:\n        <code>Failed to compile with x errors : This  dependency was not found !</code>\n      </h2>\n      <p>编译错误,对应的依赖没找到!!!</p>\n      <p>解决如下:</p>\n      <ul>\n        <li>知道缺少对应的模块,直接装进去</li>\n        <li>若是一个你已经安装的大模块(比如 axios)里面的子模块(依赖包)出了问题,卸载重装整个大模块.因为你补全不一定有用!</li>\n      </ul>\n      <hr>\n      <h2 class="heading" data-id="heading-53">Q:SyntaxError: Unexpected identifier;</h2>\n      <p>语法错误,看错误信息去找到对应的页面排查!!!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-54">Q: 为什么我的\n        <code>npm</code> 或者\n        <code>yarn</code> 安装依赖会生成\n        <code>lock</code>文件,有什么用!</h2>\n      <p>lock 文件的作用是统一版本号,这对团队协作有很大的作用;</p>\n      <p>若是没有 lock 锁定,根据\n        <code>package.json</code>里面的\n        <code>^</code>,\n        <code>~</code>这些..</p>\n      <p>不同人,不同时间安装出来的版本号不一定一致;</p>\n      <p>有些包甚至有一些\n        <code>breaking change</code>(破坏性的更新),造成开发很难顺利进行!!!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-55">Q: 组件可以缓存么?</h2>\n      <p>可以,用\n        <code>keep-alive</code>;</p>\n      <p>不过是有代价的..占有内存会多了...所以无脑的缓存所有组件!!!别说性能好了..切换几次,\n        <br>有些硬件 hold不住的,浏览器直接崩溃或者卡死..</p>\n      <p>所以\n        <code>keep-alive</code>一般缓存都是一些列表页,不会有太多的操作,更多的只是结果集的更换..</p>\n      <p>给路由的组件\n        <code>meta</code>增加一个标志位,结合\n        <code>v-if</code>就可以按需加上缓存了!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-56">Q:\n        <code>package.json</code>里面的\n        <code>dependencies</code> 和\n        <code>devDependencies</code>的差异!</h2>\n      <p>其实不严格的话,没有特别的差异;\n        <br>若是严格,遵循官方的理解;</p>\n      <ul>\n        <li>\n          <code>dependencies</code> : 存放线上或者业务能访问的核心代码模块,比如\n          <code>vue</code>,\n          <code>vue-router</code>;</li>\n        <li>\n          <code>devDependencies</code>: 处于开发模式下所依赖的开发模块,也许只是用来解析代码,转义代码,但是不产生额外的代码到生产环境, 比如什么\n          <code>babel-core</code>这些</li>\n      </ul>\n      <p>如何把包安装到对应的依赖下呢?</p>\n      <pre><code class="hljs javascript" lang="JavaScript">\n  npm install --save xxxx <span class="hljs-comment">// dependencies</span>\n  npm install --save-dev xxxx <span class="hljs-comment">// devDependencies</span>\n\n  <span class="hljs-comment">//也能用简易的写法(i:install,-S:save,-D:save-dev)</span>\n\n  npm i -S xxxx <span class="hljs-comment">// npm install --save xxxx</span>\n  npm i -D xxxx <span class="hljs-comment">// npm install --save-dev xxxx</span></code></pre>\n      <hr>\n      <h2 class="heading" data-id="heading-57">Q: 安装\n        <code>chromedriver</code>报错!!姿势没错啊\n        <code>npm i -D chromedriver</code>\n      </h2>\n      <p>恩,伟大的 GFW.....解决方案:指定国内的源安装就可以了</p>\n      <p>\n        <code>npm install --save-dev chromedriver --chromedriver_cdnurl=<a href="http://cdn.npm.taobao.org/dist/chromedriver">http://cdn.npm.taobao.org/dist/chromedriver</a></code>\n      </p>\n      <hr>\n      <h2 class="heading" data-id="heading-58">Q:Vue ,React, Angular学习哪个好?哪个工作比较好找!</h2>\n      <p>Vue属于渐进式开发,传统开发过渡 MVVM 模式的小伙伴,\n        <code>Vue</code> 比较好上手,学习成本比较低\n        <br>基础比较好的,有折腾精神的,可以选择\n        <code>NG5</code>或者\n        <code>React 16</code>;</p>\n      <p>NG5需要学习\n        <code>typescript</code>和\n        <code>rxjs</code>,还用到比较多的新东西,比如装饰器,后端的注入概念.ng有自己的一整套 MVVM 流程;</p>\n      <p>而\n        <code>Vue</code>和\n        <code>React</code>核心只是\n        <code>view</code>,可以搭配自己喜欢的</p>\n      <p>\n        <code>React</code>的写法偏向函数式写法,还有 jsx,官方自己有\n        <code>flow</code>,当然也能搭配\n        <code>ts</code>,我也没怎么接触..所以也有一定的学习成本;</p>\n      <p>至于哪个比较好找工作!!!告诉你..若是只会一个框架,那不是一个合格的前端;</p>\n      <p>人家要的是动手能力,解决能力!!!!\n        <strong>技术和待遇是成正比的</strong>!!</p>\n      <p>颜值和背景,学历,口才可以加分..但是这些条件你必须要有的基础下才能考虑这些!!!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-59">Q: 我有个复杂组件需要有新增和编辑的功能同时存在,但是字段要保持不变性怎么破</h2>\n      <p>字段保持不变性怎么理解呢? 就是说比如新增和编辑同时共享一份\n        <code>data</code>;</p>\n      <p>有一种就是路由变了,组件渲染同一个(不引起组件的重新渲染和销毁!),但是功能却不同(新增和编译)..</p>\n      <p>比如从编辑切到新增,\n        <code>data</code>必须为空白没有赋值的,等待我们去赋值;</p>\n      <p>这时候有个东西就特别适合了,那就是\n        <a href="https://link.juejin.im?target=https%3A%2F%2Ffacebook.github.io%2Fimmutable-js%2F" target="_blank"\n          rel="nofollow noopener noreferrer">immutable-js</a>;</p>\n      <p>这个东西可以模拟数据的唯一性!或者叫做不变性!</p>\n      <hr>\n      <h2 class="heading" data-id="heading-60">Q:&quot;首屏加载比较慢!!怎么破!打包文件文件比较大&quot;</h2>\n      <p>依次排除和确认:</p>\n      <ul>\n        <li>减少第三方库的使用,比如\n          <code>jquey</code>这些都可以不要了,很少操作 dom,而且原生基本满足开发</li>\n        <li>若是引入\n          <code>moment</code>这些,webpack 排除国际化语言包</li>\n        <li>webpack 常规压缩js,css, 愿意折腾的还可以引入 dll 这些</li>\n        <li>路由组件采用懒加载</li>\n        <li>加入路由过渡和加载等待效果,虽然不能解决根本,但起码让人等的舒心一点不是么!!!</li>\n      </ul>\n      <p>整体下来,打包之后一般不会太大;</p>\n      <p>但是倘若想要更快?那就只能采用服务端渲染(SSR)了,可以避免浏览器去解析模板和指令这些;\n        <br>直接返回一个 html ....还能 SEO...</p>\n      <hr>\n      <h2 class="heading" data-id="heading-61">Q: Vue SPA 没法做优化(SEO)!有解决方案么</h2>\n      <p>可以的,SSR(服务端渲染就能满足你的需求),因为请求回来就是一个处理完毕的 html</p>\n      <p>现在 vue 的服务端开发框架有这么个比较流行,如下</p>\n      <p>传送门:\n        <a href="https://link.juejin.im?target=https%3A%2F%2Fzh.nuxtjs.org%2F" target="_blank" rel="nofollow noopener noreferrer">Nuxt.js</a>\n      </p>\n      <hr>\n      <h2 class="heading" data-id="heading-62">Q: Vue可以写 hybird App 么!</h2>\n      <p>当然可以,两个方向.</p>\n      <ul>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fcordova.apache.org%2F" target="_blank" rel="nofollow noopener noreferrer">codorva</a> +\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Frigor789%2Fnativescript-vue" target="_blank"\n            rel="nofollow noopener noreferrer">nativescript</a>\n        </li>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fweex.apache.org%2F" target="_blank" rel="nofollow noopener noreferrer">Weex</a>\n        </li>\n      </ul>\n      <hr>\n      <h2 class="heading" data-id="heading-63">Q: Vue 可以写桌面端么?</h2>\n      <p>当然可以,有\n        <code>electron</code>和\n        <code>node-webkit(nw)</code>;</p>\n      <p>我只了解过\n        <code>electron</code>;</p>\n      <ul>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Felectron.atom.io%2F" target="_blank" rel="nofollow noopener noreferrer">electron</a>\n        </li>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FSimulatedGREG%2Felectron-vue" target="_blank" rel="nofollow noopener noreferrer">electron-vue</a>: Vue-cli 针对 electron 的脚手架模板</li>\n      </ul>\n      <hr>\n      <h2 class="heading" data-id="heading-64">Q: Vue开发,项目中还需要\n        <code>jQuery</code>么</h2>\n      <p>分情况探讨:</p>\n      <ol>\n        <li>若是老项目,只是单纯引入 Vue 简化开发的,依旧用吧...</li>\n        <li>重构项目?或者发起新项目的,真心没必要了.开发思路不一样,很多以前用 DOM 操作的现在基本可以数据驱动实现,而少量迫不得已的DOM 操作原生就能搞定...而且能减小打包体积,速度又快,何乐而不为!!!</li>\n      </ol>\n      <hr>\n      <h2 class="heading" data-id="heading-65">Q:Vue PC(桌面)端,M(mobile:移动)端,用什么 UI 框架好啊!!!</h2>\n      <p>\n        <strong>PC</strong>\n      </p>\n      <p>我推荐的只有两个\n        <code>element UI</code>和\n        <code>iview</code>\n      </p>\n      <p>\n        <strong>Mobile</strong>\n      </p>\n      <p>\n        <code>Vux</code>\n      </p>\n      <p>当然还有很多,但是基本用户的认知度都不高,这三个比较流行</p>\n      <hr>\n      <h2 class="heading" data-id="heading-66">Q: Vue可以写微信小程序么,怎么搞起</h2>\n      <p>可以的,社区也有人出了对应的解决方案,比如比较流行的方案\n        <code>wepy</code>;\n        <br>\n        <code>wepy</code>你也可以理解为一个脚手架,让你的写小程序的方式更贴近你用\n        <code>vue-cli</code>写 vue 的感觉...</p>\n      <p>传送门:\n        <a href="https://link.juejin.im?target=https%3A%2F%2Fwepyjs.github.io%2Fwepy%2F%23%2F" target="_blank" rel="nofollow noopener noreferrer">wepy</a>\n      </p>\n      <hr>\n      <h2 class="heading" data-id="heading-67">Q:想要 mock 数据,直接请求\n        <strong>json文件</strong> 为什么不行!</h2>\n      <p>当然不行,浏览器安全机制不允许,JS天生不能越权(NodeJS不能单纯说是JS)</p>\n      <p>你要 mock 数据,一般都有比较成熟的方案...传送门:</p>\n      <ul>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fnuysoft%2FMock" target="_blank" rel="nofollow noopener noreferrer">Mock</a>\n        </li>\n        <li>\n          <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Feasy-mock%2Feasy-mock" target="_blank" rel="nofollow noopener noreferrer">Easy Mock</a>\n        </li>\n      </ul>\n      <hr>\n      <h1 class="heading" data-id="heading-68">Vue 周边库汇总</h1>\n      <p>\n        <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fawesome-vue" target="_blank" rel="nofollow noopener noreferrer">\n          <strong>Awesome Vue</strong>\n        </a> : 里面收集了 Vue 方方面面的热门库!!</p>\n      <hr>\n      <h1 class="heading" data-id="heading-69">Vue 最近的动态</h1>\n      <ul>\n        <li>据说 Vue 3 打算用\n          <code>Proxy</code>拦截器来做数据拦截及响应..这样可以检测到更多数据类型的响应;不过 IE系列全军覆没,\n          <code>polyfill</code> 都不行</li>\n        <li>Vue 目前最新 2.5.3 核心库已适配\n          <code>typescript 2.6</code>; 但是周边库没跟上(比如第三方的 UI 框架,没有更新对应的\n          <code>d.ts</code>编译器会报错)..若是组件基本都是自己去写,用\n          <code>ts+vue</code>开发已经没什么特别的坑了...</li>\n      </ul>\n      <hr>\n        <figcaption></figcaption>\n      </figure>\n      <p></p>\n    </div>\n  </div>\n</div>'},lDDU:function(n,e){n.exports='<h1 id="vs-code">VS Code</h1>\n<p>Visual Studio Code是一个轻量级的Web集成开发环境，推荐你使用。<br><a href="https://code.visualstudio.com/" target="vscode-offical">官网下载地址</a><br><a href="javascript:alert(\'暂无\')">资料库下载地址</a>  </p>\n<h2 id="-">配置</h2>\n<p>进入文件菜单，打开首选项进行编辑器相关配置，各扩展的配置也在此处。</p>\n<h2 id="-">命令行终端</h2>\n<p>进入查看菜单，打开集成终端，即可在编辑器内使用终端工具。</p>\n<h2 id="-">扩展</h2>\n<p>进入查看菜单，打开扩展，可搜索扩展并安装使用。<br>由于我们的开发模板中已经集成了不少基于node的功能，此处只介绍几个可单独安装的扩展。</p>\n<h4 id="vue-">vue支持</h4>\n<p><strong>Vetur</strong>: vue的VS Code工具。<br>注：当我们打开一个项目的.vue文件，vscode会提示我们安装此扩展。</p>\n<h4 id="-">主题</h4>\n<p><strong>Atom One Dark Theme</strong> 一个编辑器颜色与高亮主题<br><strong>Atom One Light Theme</strong> 一个编辑器颜色与高亮主题  </p>\n<h4 id="-">版本控制</h4>\n<p>VSCode集成了基于git的版本控制<br>使用svn进行版本控制暂时没有发现好用的扩展，使用的是外部图形化工具。</p>\n<h4 id="-">便捷工具</h4>\n<p><strong>Auto-Open Markdown Preview</strong> 当你开启一个markdown文件时，自动打开一个markdown预览模式的窗口。</p>\n'},oWyZ:function(n,e,s){"use strict";var a=s("NL57"),o=(s.n(a),s("zVPd")),t=s.n(o),p=s("jk9C"),l=s.n(p),c=s("lDDU"),d=s.n(c),i=s("tNCZ"),r=s.n(i),h=s("ekGF"),u=s.n(h),g=s("yebT"),m=s.n(g),j=s("wJmA"),f=s.n(j),v=s("qiTU"),b=s.n(v),x=s("jDjW"),k=s.n(x),w=s("3Ixl"),y=s.n(w),q=s("lBI2"),F=s.n(q),Q=s("Ni3J"),S=s.n(Q);s.d(e,"h",function(){return t.a}),s.d(e,"i",function(){return l.a}),s.d(e,"e",function(){return d.a}),s.d(e,"g",function(){return r.a}),s.d(e,"k",function(){return u.a}),s.d(e,"b",function(){return m.a}),s.d(e,"d",function(){return f.a}),s.d(e,"c",function(){return b.a}),s.d(e,"j",function(){return k.a}),s.d(e,"f",function(){return y.a}),s.d(e,"l",function(){return F.a}),s.d(e,"a",function(){return S.a})},qiTU:function(n,e){n.exports='<h1 id="-">图表库</h1>\n<p>图表库推荐使用<strong>ECharts.js</strong>。也可使用<strong>HightChart.js</strong>。</p>\n<h1 id="echarts">ECharts</h1>\n<p><a href="http://echarts.baidu.com/option.html" target="echarts-offical-options">官网配置api</a><br>\x3c!-- 同时目前我们的模板依赖中默认添加了**ECharts.js**，使用`npm install`即可自动安装。   --\x3e</p>\n<p>使用方式：</p>\n<pre><code>import echarts from &#39;echarts&#39;\n</code></pre><pre><code class="lang-html">&lt;div id=&quot;charts&quot;&gt;\n    &lt;div id=&quot;main&quot;  :style=&quot;{width:&#39;600px&#39;,height:&#39;400px&#39;}&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-vue">mounted (){\n  this.myChart = echarts.init(document.getElementById(&#39;main&#39;))\n  myChart.setOption({\n    // ...\n  })\n}\n</code></pre>\n<h1 id="highcharts">Highcharts</h1>\n<p><a href="https://api.hcharts.cn/highcharts" target="highcharts-offical">官网文档</a></p>\n<p>需要手动安装\n<code>npm i highcharts --save</code><br>使用相同</p>\n'},tNCZ:function(n,e){n.exports='<h1 id="-">项目初始化</h1>\n<h2 id="-">我们的项目</h2>\n<p>我们的项目模板是由<code>vue-cli</code>脚手架的<code>webpack</code>模板改动而来的。<br>可以<a href="javascript:alert(\'暂无\')">点击下载</a></p>\n<p>下载解压后，进入文件夹，执行<code>npm install</code>，依赖安装完成后即可进行开发。<br><strong>注</strong>：一般在进行版本控制时，会将<code>node_modules</code>文件夹加入各版本控制工具的ignore列表不进行上传。</p>\n<h2 id="vue-">vue项目</h2>\n<p>除了自己搭建一个vue项目，vue提供了vue-cli脚手架工具和6个模板方便你快速开始项目。</p>\n<p><a href="https://github.com/vuejs/vue-cli" target="vue-cli-offical">官方文档</a></p>\n<h4 id="-">模板：</h4>\n<ol>\n<li><p>webpack - 一个功能齐全的Webpack + vue-loader模板，带有热重新加载，linting，测试和css提取。我们目前使用的模板就是由它改动而来。</p>\n</li>\n<li><p>webpack-simple - 一个简单的Webpack + vue-loader，用于快速原型设计的模板。</p>\n</li>\n<li><p>browserify - 全功能的Browserify + vueify的模板，包括热重新加载，linting和单元测试。</p>\n</li>\n<li><p>browserify-simple - 一个简单的Browserify + vueify设置快速模板。</p>\n</li>\n<li><p>pwa - 基于webpack的PWA模板。</p>\n</li>\n<li><p>simple - 我是个html。</p>\n</li>\n</ol>\n<h4 id="-vue-cli">使用vue-cli</h4>\n<ol>\n<li>先全局安装<code>npm i vue-cli -g</code></li>\n<li>去要初始化项目的路径下执行<code>vue init [模板名] [项目名]</code>，然后vue-cli命令行会询问相关配置，然后进入项目路径执行<code>npm i</code>，依赖安装完毕后即可进行开发。</li>\n</ol>\n<p>vue-cli命令行参数</p>\n<ol>\n<li><code>vue init [模板名] [项目名]</code></li>\n<li><code>vue init [模板名]#[version] [项目名]</code> 以模板的指定tag或branch进行初始化。</li>\n<li><code>vue init [username]/[repo] [项目名]</code> 以github上，username用户的[repo]库进行初始化。</li>\n</ol>\n'},wJmA:function(n,e){n.exports='<h1 id="-">组件库</h1>\n<p>使用<strong>Element-ui</strong>。<br>\x3c!-- 同时目前我们的模板依赖中默认添加了**Element-ui**组件库，使用`npm install`即可自动安装。  \n目前项目的组件使用此组件库组件，后续会根据业务需求添加自己的组件。 --\x3e</p>\n<p>使用方式：</p>\n<pre><code>import ElementUI from &#39;element-ui&#39;\nVue.use(ElementUI)\n</code></pre><p>然后即可使用Element-ui组件。</p>\n<p><a href="http://element.eleme.io/#/zh-CN" target="ele-offical">Element-ui 中文官网</a><br><a href="http://element.eleme.io/#/zh-CN/component/installation" target="ele-offical">Element-ui 组件文档</a><br><a href="https://github.com/ElemeFE/element" target="ele-offical">Element-ui 源代码</a></p>\n'},yebT:function(n,e){n.exports='<h1 id="ajax">AJAX</h1>\n<p>AJAX库指定使用<strong>axios.js</strong>。<br>axios基于Promise Api实现的，需要做兼容处理。<br>其他使用问题可查看<strong>具体问题</strong>部分。<br>高级用法可查看demo部分、<a href="https://www.kancloud.cn/yunye/axios/234845" target="axios-cn">中文文档</a>、<a href="https://github.com/axios/axios" target="axios-offical">官方文档</a></p>\n<h2 id="-">指南</h2>\n<h4 id="-">安装</h4>\n<p>安装axios与兼容包<br><code>npm i axios es6-promise --save</code>  </p>\n<h4 id="-">导入</h4>\n<pre><code>// 配置兼容\nimport &#39;es6-promise/auto&#39;\n// 配置axios\nimport &#39;axios&#39; from &#39;axios&#39;\n// 将axios挂载到Vue\nVue.prototype.$http = axios\n</code></pre><h4 id="-">使用</h4>\n<p>组件内使用：</p>\n<pre><code>this.$http.axios.post(&#39;/user&#39;, {\n  firstName: &#39;Fred&#39;,\n  lastName: &#39;Flintstone&#39;\n})\n.then(function (response) {\n  // 成功\n  console.log(response);\n})\n.catch(function (error) {\n  // 错误\n  console.log(error);\n})\n</code></pre>'},zVPd:function(n,e){n.exports='<h1 id="node-js">Node.js</h1>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。<br>Node.js 的包管理器 npm，是全球最大的开源库生态系统。<br>我们使用npm安装和管理项目依赖。<br>使用Node.js进行项目的开发和打包。  </p>\n<h2 id="-">下载</h2>\n<p><a href="http://nodejs.cn/download/" target="node-official">官网下载地址</a><br><a href="javascript:alert(\'暂无\')">资料库下载地址</a></p>\n<h2 id="node-">node安装</h2>\n<ol>\n<li>打开文件进行下一步安装，可自行修改安装路径。</li>\n<li>过程中会直接添加path的系统变量，变量值是你的安装路径，例如“C:\\Program Files\\nodejs”。</li>\n<li>安装完成后可执行<code>node -v</code>检查是否安装成功，如有<code>&#39;node&#39; 不是内部或外部命令，也不是可运行的程序</code>相关报错，需手动添加系统环境变量。</li>\n</ol>\n<h2 id="npm">npm</h2>\n<p>npm为包管理工具，在安装node时会随node自动安装。</p>\n'}});
//# sourceMappingURL=0.29fd8db977d0b5d8fcf4.js.map